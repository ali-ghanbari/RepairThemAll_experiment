cd /tmp/NPEFix_Defects4J_Closure_106;
export JAVA_TOOL_OPTIONS="-Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en";
TZ="America/New_York"; export TZ;
export PATH="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/:$PATH";
export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/";
time java -Xmx4g -Xms1g -cp /home/tdurieux/RepairThemAll/script/../repair_tools/npefix.jar fr.inria.spirals.npefix.main.run.Main \
    --test com.google.javascript.jscomp.CollapsePropertiesTest:com.google.javascript.jscomp.CheckSideEffectsTest \
    --iteration 100 \
	--complianceLevel 7 \
	--workingdirectory . \
	--source src/ \
	--classpath build/classes/:build/test/:/tmp/NPEFix_Defects4J_Closure_106/build/classes:/tmp/NPEFix_Defects4J_Closure_106/build/test:/tmp/NPEFix_Defects4J_Closure_106/lib/junit.jar:/tmp/NPEFix_Defects4J_Closure_106/lib/libtrunk_rhino_parser_jarjared.jar:/tmp/NPEFix_Defects4J_Closure_106/lib/google_common_deploy.jar:/tmp/NPEFix_Defects4J_Closure_106/lib/google_compiled_protos_deploy.jar;
	echo "\n\nNode: `hostname`\n";
	echo "\n\nDate: `date`\n";
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en
TernarySplitter  in 331ms
return (current) != null
return (cur) != null
Preconditions.checkArgument(((child.parent) == null), "new child has existing parent")
Preconditions.checkArgument(((child.next) == null), "new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null), "first new child has existing parent")
Preconditions.checkArgument(((left.next) == null), "first new child has existing sibling")
Preconditions.checkArgument(((right.parent) == null), "second new child has existing parent")
Preconditions.checkArgument(((right.next) == null), "second new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((mid2.parent) == null))
Preconditions.checkArgument(((mid2.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((children[(i - 1)].parent) == null))
Preconditions.checkArgument(((children[((children.length) - 1)].parent) == null))
return (first) != null
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument((node != null), "The existing child node of the parent should not be null.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
return ((first) != null) && ((first) == (last))
return ((first) != null) && ((first) != (last))
return (checkTreeEqualsImpl(node2)) == null
Preconditions.checkState(((parent) != null))
Preconditions.checkArgument(((prev.next) != null), "no next sibling.")
boolean initialized = (name.declaration) != null
Preconditions.checkState(((blacklist != null) && (!(blacklist.isEmpty()))), "Not checking use of goog.getCssName because of empty blacklist.")
return (((parent == null) || ((parent.getType()) != (Token.FUNCTION))) || (n == (parent.getFirstChild()))) || (parent == (scope.getRootNode()))
Preconditions.checkState(((sourceName) != null))
boolean isFnLiteral = (rValue != null) && ((rValue.getType()) == (Token.FUNCTION))
defineSlot(name, parent, type, (type == null))
Preconditions.checkArgument((inferred || (type != null)))
scope.declare((variableName + ".prototype"), n, fnType.getPrototype(), compiler.getInput(sourceName), ((superClassCtor == null) || (superClassCtor.getInstanceType().equals(typeRegistry.getNativeType(JSTypeNative.OBJECT_TYPE)))))
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
inferred = !(((rhsValue != null) && ((rhsValue.getType()) == (Token.FUNCTION))) && (!(scope.isDeclared(qName, false))))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkState(((parent.getFirstChild()) == null))
boolean checkModules = isRemovable && (fnModule != null)
Preconditions.checkState((var != null), "Type tightener could not find variable with name %s", lhs.getString())
Preconditions.checkState((variable != null))
allowDupe = (info != null) && (info.getSuppressions().contains("duplicate"))
compiler.report(JSError.make(sourceName, nodeWithLineNumber, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, name, ((origVar.input) != null ? origVar.input.getName() : "??")))
Preconditions.checkState(((scope.getParent()) == null))
Preconditions.checkArgument((((node == null) || (NodeUtil.isVar(node))) || (NodeUtil.isExpressionNode(node))))
Preconditions.checkArgument(((node == null) == (parent == null)))
Preconditions.checkArgument(((node == null) == (parent == null)))
return (((name.parent) != null) && ((name.parent.aliasingGets) == 0)) && ((name.parent.type) == (OBJECTLIT))
return (waiting) == null
return (isDeclaration()) && (((parent.getType()) != (Token.VAR)) || ((nameNode.getFirstChild()) != null))
return (((((parentType == (Token.VAR)) && ((nameNode.getFirstChild()) != null)) || (parentType == (Token.INC))) || (parentType == (Token.DEC))) || ((NodeUtil.isAssignmentOp(parent)) && ((parent.getFirstChild()) == (nameNode)))) || (ReferenceCollectingCallback.Reference.isLhsOfForInExpression(nameNode))
boolean hasObjectValues = (values) != null
return (n.getFirstChild()) != null
return (gramps == null) || ((gramps.getType()) != (Token.SCRIPT))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
this.call = new ArrowType(registry, parameters, (returnType == null ? getReturnType() : returnType))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
Preconditions.checkArgument((name != null))
return ((prototype) != null) || (super.hasCachedValues())
this(sourceName, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
this(sourceName, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
return ((((((type.key) + ". ") + (description)) + " at ") + (((sourceName) != null) && ((sourceName.length()) > 0) ? sourceName : "(unknown source)")) + " line ") + ((lineNumber) != (-1) ? String.valueOf(lineNumber) : "(unknown line)")
return classes != null
return ((activationNames) != null) && (activationNames.containsKey(name))
boolean aliasable = (!(unaliasableGlobals.contains(dest.getString()))) && ((docInfo == null) || (!(docInfo.isNoAlias())))
return !((functionName == null) || (!(ExportTestFunctions.TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches())))
return (that.parameters) == null
Preconditions.checkState(((this.newName) == null))
boolean local = (var != null) && (var.isLocal())
return (qname != null) && (isIdName(qname))
return ((((((type == null) || (!(type instanceof ObjectType))) || (invalidatingTypes.contains(type))) || (!(((ObjectType) (type)).hasName()))) || ((type.isNamedType()) && (type.isUnknownType()))) || (type.isEnumType())) || ((type.autoboxesTo()) != null)
return ((((((type == null) || (!(type instanceof ObjectType))) || (invalidatingTypes.contains(type))) || (!(((ObjectType) (type)).hasName()))) || ((type.isNamedType()) && (type.isUnknownType()))) || (type.isEnumType())) || ((type.autoboxesTo()) != null)
return (fn) != null
Preconditions.checkState(((this.fn) == null))
return ((references) != null) && (!(references.isEmpty()))
Preconditions.checkArgument((compiler != null))
Preconditions.checkArgument((safeNameIdSupplier != null))
Preconditions.checkArgument((changed != null))
Preconditions.checkState((fn != null))
Preconditions.checkArgument((paths != null))
Preconditions.checkArgument((showType != null))
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState(((currentTracer) == null))
Preconditions.checkState(((currentTracer) != null), "Tracer should not be null at the end of a pass.")
Preconditions.checkState(((getInput(sourceName)) == null), ("Duplicate input of name " + sourceName))
Preconditions.checkState((convention != null))
return (lastChild != null) && ((lastChild.isOptionalArg()) || (lastChild.isVarArgs()))
return (lastChild != null) && (lastChild.isVarArgs())
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && ((scopeRootParent.getType()) == (Token.ASSIGN))) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && ((scopeRootParent.getType()) == (Token.ASSIGN))) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && ((scopeRootParent.getType()) == (Token.ASSIGN))) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (CheckAccessControls.getTypeDeprecationInfo(type)) != null
Preconditions.checkArgument(((declaration.getJSType()) != null))
return ((input) == null) || (input.isExtern())
Preconditions.checkState(((name != null) && ((name.length()) > 0)))
Preconditions.checkState(((vars.get(name)) == null))
var.isDefine = (info != null) && (info.isDefine())
return (parent) == null
Preconditions.checkState((expressionRoot != null))
Preconditions.checkArgument(((lastLink.nextLink) == null))
return ((warningsGuard) != null) && (warningsGuard.enables(type))
Preconditions.checkArgument((unsafe != null))
return ((!(skipRenaming)) && ((types) != null)) && ((types.allEquivalenceClasses().size()) > 1)
compiler.report(JSError.make(t.getSourceName(), n, DisambiguateProperties.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString()))
compiler.report(JSError.make(t.getSourceName(), child, DisambiguateProperties.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString()))
return (((type == null) || (invalidatingTypes.contains(type))) || ((type instanceof ObjectType) && (!(((ObjectType) (type)).hasName())))) || ((type.isNamedType()) && (type.isUnknownType()))
return (type.isEnumType()) || ((type.autoboxesTo()) != null)
return (((type == null) || (type.isAll())) || (type.isFunction())) || ((type.isInstance()) && (invalidatingTypes.contains(type.toInstance().instanceType)))
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
Preconditions.checkState(((scopeCreator) == null))
Preconditions.checkState(((topScope) == null))
Preconditions.checkState(((jsRoot.getParent()) != null))
boolean superClassHasProperty = (superClass != null) && (superClass.getPrototype().hasProperty(propertyName))
boolean declaredOverride = (info != null) && (info.isOverride())
return ((parent == null) || ((parent.getType()) != (Token.SCRIPT))) || (!(t.getInput().isExtern()))
Preconditions.checkState(((gramps != null) && ((gramps.getType()) == (Token.VAR))))
return (info != null) && (((info.isConstructor()) && (valueNodeType == (Token.FUNCTION))) || ((info.hasEnumParameterType()) && (valueNodeType == (Token.OBJECTLIT))))
return (!(inExterns)) && ((isClassOrEnum) || ((((parent) == null) || (parent.canCollapseUnannotatedChildNames())) && (((globalSets) > 0) || ((localSets) > 0))))
return (((type) == (GlobalNamespace.Name.Type.FUNCTION)) || ((aliasingGets) == 0)) && (((parent) == null) || (parent.canCollapseUnannotatedChildNames()))
return (parent) == null
return (v != null) && (!(v.isLocal()))
return (s.getParent()) == null
Preconditions.checkState((((body.getNext()) == null) && ((body.getType()) == (Token.BLOCK))))
return (getNode(n)) != null
return (((n != null) && ((n.getType()) == (Token.CALL))) && (n.hasChildren())) && ((qualifiedNameBeginsWithStripType(n.getFirstChild())) || (nameEndsWithFieldNameToStrip(n.getFirstChild())))
return ((propNode != null) && ((propNode.getType()) == (Token.STRING))) && (isStripName(propNode.getString()))
return (((name != null) && (NodeUtil.isName(name))) && (var.getName().equals(name.getString()))) && (NodeUtil.isAssignmentOp(n))
return (((name != null) && (NodeUtil.isName(name))) && (var.getName().equals(name.getString()))) && (!(NodeUtil.isLhs(name, name.getParent())))
return ((gramp.hasOneChild()) && (docInfo != null)) && (docInfo.isNoSideEffects())
return (docInfo != null) && (docInfo.isNoSideEffects())
return (currentInfo.getDescription()) != null
assert record != null
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
allowDupe = (info != null) && (info.getSuppressions().contains("duplicate"))
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isOptionalArg())
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isVarArgs())
return (properties.get(propertyName)) != null
return (className) != null
return (input != null) && ((input.getType()) == (Token.RETURN))
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
Preconditions.checkState((externsAndJs != null))
return (var != null) && (var.isConst())
Preconditions.checkState((nameNode != null))
Preconditions.checkState((value != null))
Preconditions.checkState((value != null))
return (initialization.getNameNode().getFirstChild()) != null
return !(((ancestors.size()) == 1) && ((ancestors.peek().getNext()) == null))
this.valueHasSideEffects = (valueNode != null) && (NodeUtil.mayHaveSideEffects(valueNode))
return (lookAhead) != null
CheckNotNull  in 2950ms
Exception in thread "main" spoon.SpoonException: Cannot create MethodTypingContext for method declared in different ClassTypingContext
	at spoon.support.visitor.MethodTypingContext.setMethod(MethodTypingContext.java:71)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:616)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:312)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:959)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:955)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:78)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.sendResult(SuperInheritanceHierarchyFunction.java:360)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperInterfaces(SuperInheritanceHierarchyFunction.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:266)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:283)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:248)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:51)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:36)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.support.reflect.declaration.CtTypeImpl.getAllMethods(CtTypeImpl.java:955)
	at spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod(ImportScannerImpl.java:408)
	at spoon.reflect.visitor.ImportScannerImpl.addMethodImport(ImportScannerImpl.java:431)
	at spoon.reflect.visitor.ImportScannerImpl.visitCtExecutableReference(ImportScannerImpl.java:106)
	at spoon.support.reflect.reference.CtExecutableReferenceImpl.accept(CtExecutableReferenceImpl.java:84)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:495)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.ImportScannerImpl.computeImports(ImportScannerImpl.java:204)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.computeImports(DefaultJavaPrettyPrinter.java:293)
	at spoon.support.reflect.declaration.CtElementImpl.toString(CtElementImpl.java:252)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:118)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:29)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:81)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtConditional(CtScanner.java:345)
	at spoon.support.reflect.code.CtConditionalImpl.accept(CtConditionalImpl.java:43)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtBlock(CtScanner.java:291)
	at spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:48)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtMethod(CtScanner.java:549)
	at spoon.support.reflect.declaration.CtMethodImpl.accept(CtMethodImpl.java:70)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:327)
	at spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:68)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:119)
	at fr.inria.spirals.npefix.main.all.Launcher.instrument(Launcher.java:105)
	at fr.inria.spirals.npefix.main.run.Main.run(Main.java:61)
	at fr.inria.spirals.npefix.main.run.Main.main(Main.java:48)
Command exited with non-zero status 1
45.29user 1.16system 0:14.02elapsed 331%CPU (0avgtext+0avgdata 1421820maxresident)k
30936inputs+120outputs (15major+368586minor)pagefaults 0swaps


Node: suno-15.sophia.grid5000.fr



Date: Sat May  4 20:37:34 EDT 2019

