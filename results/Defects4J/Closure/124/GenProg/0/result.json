{
  "repair_end": "2018-12-02 12:10:10.179264", 
  "repair_begin": "2018-12-02 11:36:26.001114", 
  "patches": [
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2005/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:01.765066957 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,14 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_406/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:08.095433447 -0500\n@@ -152,7 +152,7 @@\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1484/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:47.851296861 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +195,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_984/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:04.778708099 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_516/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:29.018366513 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1092/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:28.433817478 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1980/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:44.448423316 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,25 +131,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          StringBuilder builder = new StringBuilder();\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +154,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +189,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1302/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:00:48.494957916 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1302/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:48.498958063 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_177/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:10.044918392 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +207,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_889/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:56.112158589 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,7 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1348/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:16.875992387 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,7 +187,8 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n+    int index = -1;\n+\t// No checks are needed for simple names.\n     if (node.isName()) {\n       return true;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1720/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:43.913680919 -0500\n@@ -135,24 +135,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1525/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:12.712197347 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,10 +192,10 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1286/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:35.934499450 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,12 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1735/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:53.962058153 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +187,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_534/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:43.234880197 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1115/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:43.838386345 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2030/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:09:19.957740195 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Node block = new Node(Token.BLOCK);\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2030/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:19.961740344 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      int start = 0;\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,10 +192,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_793/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:48.201662566 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      int start = 0;\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_20/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:45:05.932497466 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            int index = -1;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1486/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:02:48.827332231 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1486/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:48.827332231 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1229/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:59.909182074 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +161,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,12 +196,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1369/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:30.948504624 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1690/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:20.220803364 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,7 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1183/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:27.828005557 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +192,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1470/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:38.022940600 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,10 +191,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1580/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:47.465454654 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,7 +185,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_500/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:51:16.437911583 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_500/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:16.437911583 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1970/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:37.568166112 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_201/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:26.837523113 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1883/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:34.345798095 -0500\n@@ -134,23 +134,6 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +192,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_257/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:16.019337458 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,18 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1673/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:08.312373928 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_586/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:52:19.280180817 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_36/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:45:17.792920202 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_391/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:49:56.271003379 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1553/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:30.896855438 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1372/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:32.804572151 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,13 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1124/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:48.850571219 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          int index = -1;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,12 +185,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_192/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:20.809301577 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_892/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:57.796220263 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_425/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:20.671890411 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1712/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:33.449287420 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,7 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1499/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:56.299602973 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +189,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1418/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:58.721514316 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1852/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:14.373057667 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +161,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,13 +196,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      return true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_419/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:16.587742064 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_696/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:53:40.327146925 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_696/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:40.331147074 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1251/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:14.129702540 -0500\n@@ -134,23 +134,7 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +185,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1848/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:11.860964422 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,25 +131,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -210,8 +190,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1837/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:58.780478453 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +136,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +159,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_928/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:25.017215904 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +190,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1514/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:05.359931139 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      final String paramName = \"jscomp_throw_param\";\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +179,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1661/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:59.036039318 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,14 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1632/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:29.154960891 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1914/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:54.474549342 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,7 +191,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      int start = 0;\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1037/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:46.772273531 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,12 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_746/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:16.072474718 -0500\n@@ -135,7 +135,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n+            final String paramName = \"jscomp_throw_param\";\n+\t\t\tif (value.isQualifiedName() &&\n                 nextName.equals(value.getQualifiedName())) {\n               // If the previous expression evaluates to value of a\n               // qualified name, and that qualified name is used again\n@@ -174,7 +175,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1409/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:53.693331632 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_783/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:41.277406985 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_783/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:41.277406985 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_686/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:33.590895889 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1390/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:43.564963494 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,13 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      final String paramName = \"jscomp_throw_param\";\n+\treturn true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1394/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:46.013052494 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,19 +187,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n+    int start = 0;\n \n-    return true;\n+      final String paramName = \"jscomp_throw_param\";\n+\treturn true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1273/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:28.546229578 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_159/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:46:57.580474647 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +210,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1403/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:51.153239326 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tint index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2087/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:10:01.499275344 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_569/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:52:06.715727733 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_5/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:44:52.936034161 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_209/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:32.677739217 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +157,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +193,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_648/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:07.897935818 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_272/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:26.319715962 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1443/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:19.750277814 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_74/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:45:47.997996511 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1200/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:59:40.496470556 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1200/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:40.500470703 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,8 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_785/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:42.189440661 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_785/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:42.189440661 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_601/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:52:31.076605949 -0500\n@@ -134,23 +134,6 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1764/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:11.470714076 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,10 +191,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1599/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:58.081838419 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +197,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1173/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:22.039792913 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1307/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:51.831079618 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_864/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:55:38.055496670 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_864/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:38.059496816 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -171,8 +155,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1946/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:16.019358951 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1010/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:27.975574061 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,8 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1873/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:28.517582198 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_172/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:06.720800055 -0500\n@@ -54,7 +54,8 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n+      StringBuilder builder = new StringBuilder();\n+\t// Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n@@ -135,22 +136,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1435/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:14.694094312 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tint index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1474/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:40.467029209 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,14 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_29/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:45:12.816742847 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_669/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:22.322475338 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1007/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:57:26.263510254 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1007/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:26.267510403 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +190,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1386/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:41.932904154 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,10 +188,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_656/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:53:12.890122695 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_656/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:12.894122843 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1591/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:54.013691379 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,11 +187,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1542/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:23.556589854 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +187,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1555/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:31.808888432 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,10 +192,10 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_780/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:39.593344790 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_780/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:39.597344938 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_458/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:45.600794905 -0500\n@@ -118,8 +118,10 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tparent = next;\n+\t\t}\n           next = next.getFirstChild();\n           break;\n \n@@ -135,24 +137,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -168,16 +154,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_236/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:59.230719479 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +194,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1646/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:36.691232966 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +187,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1405/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:52.045271743 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +187,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_110/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:46:20.587157365 -0500\n@@ -141,7 +141,8 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n+              StringBuilder builder = new StringBuilder();\n+\t\t\t// Verify the assignment doesn't change its own value.\n               if (!isSafeReplacement(next, assign)) {\n                 return false;\n               }\n@@ -174,7 +175,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1492/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:52.083450220 -0500\n@@ -118,10 +118,12 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +137,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1940/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:11.887203882 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1216/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:52.216900280 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_882/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:55:50.935968960 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_882/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:50.939969106 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1079/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:18.437447770 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,12 +191,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1527/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:13.532227034 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,10 +187,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1004/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:19.319251280 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +189,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_738/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:12.692349456 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1452/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:25.502486521 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1756/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:07.370560626 -0500\n@@ -54,7 +54,8 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n+      final String paramName = \"jscomp_throw_param\";\n+\t// Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n@@ -135,22 +136,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,7 +193,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1169/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:59:19.599703234 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1169/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:19.599703234 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1828/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:53.720290251 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -210,8 +192,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1164/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:59:16.139576030 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1164/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:16.143576178 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_673/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:24.114542273 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_862/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:55:37.191464966 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_862/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:37.191464966 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_937/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:56:31.313452901 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_937/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:31.317453051 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1192/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:34.536251854 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_557/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:58.299424071 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_300/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:48.928545147 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,18 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1610/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:09.430248494 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1433/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:13.870064401 -0500\n@@ -146,7 +146,8 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n+              int start = 0;\n+\t\t\texprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -174,7 +175,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 123, 
          "faulty": "next=next.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1458/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:29.562633800 -0500\n@@ -120,7 +120,10 @@\n         case Token.EXPR_RESULT:\n           // Dive down the left side\n           parent = next;\n-          next = next.getFirstChild();\n+          {\n+\t\t\tint start = 0;\n+\t\t\tnext = next.getFirstChild();\n+\t\t}\n           break;\n \n         case Token.VAR:\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +161,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,10 +194,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_849/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:27.855122214 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            final String paramName = \"jscomp_throw_param\";\n           }\n           return false;\n \n@@ -174,7 +159,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1212/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:49.628805427 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +185,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1760/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:09.002621719 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1909/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:51.146424032 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,25 +131,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +154,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,11 +183,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1612/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:10.250278119 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,14 +189,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n+    int start = 0;\n \n+      int index = -1;\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1994/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:54.428795304 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,25 +131,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          StringBuilder builder = new StringBuilder();\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +154,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1686/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:17.700712495 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,14 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1516/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:06.179960834 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +179,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_472/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:56.505190041 -0500\n@@ -133,26 +133,11 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n-          return false;\n+          ;\n+          {\n+\t\t\tint index = -1;\n+\t\t\treturn false;\n+\t\t}\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_49/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:45:27.701273312 -0500\n@@ -171,10 +171,11 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n+            final String paramName = \"jscomp_throw_param\";\n+\t\t\t// Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            int index = -1;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_876/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:47.491842731 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_379/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:49:48.894734878 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +207,8 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n+\tPreconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1420/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:59.537543960 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_222/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:42.642107502 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_304/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:51.384635098 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,18 +203,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1326/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:02.739477364 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_409/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:09.731492918 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      int index = -1;\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_944/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:35.941626938 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2081/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:57.335121588 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +192,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1398/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:48.633147734 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1247/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:00:12.477642106 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1247/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:12.481642252 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1578/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:46.657425440 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            int start = 0;\n           }\n           return false;\n \n@@ -168,16 +153,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +184,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1640/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:33.435115421 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,14 +188,11 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n+    int index = -1;\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_976/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:56:59.758520265 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_976/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:59.762520416 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1899/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:45.098196132 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_389/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:49:55.454973684 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_384/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:49:52.158853715 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 123, 
          "faulty": "next=next.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1283/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:34.246437803 -0500\n@@ -120,7 +120,10 @@\n         case Token.EXPR_RESULT:\n           // Dive down the left side\n           parent = next;\n-          next = next.getFirstChild();\n+          {\n+\t\t\tfinal String paramName = \"jscomp_throw_param\";\n+\t\t\tnext = next.getFirstChild();\n+\t\t}\n           break;\n \n         case Token.VAR:\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +161,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +196,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1154/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:09.455330173 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +185,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1280/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:32.610378047 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_999/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:57:15.815120495 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_999/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:15.815120495 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1506/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:00.371750481 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1311/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:53.467139291 -0500\n@@ -135,24 +135,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_579/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:52:14.227998665 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2020/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:12.457462712 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +184,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_265/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:21.155526256 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1253/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:14.941732242 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1309/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:52.647109383 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,14 +179,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1364/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:27.680385703 -0500\n@@ -118,10 +118,12 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +137,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_561/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:52:00.747512413 -0500\n@@ -134,23 +134,6 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,7 +187,8 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n+    StringBuilder builder = new StringBuilder();\n+\t// No checks are needed for simple names.\n     if (node.isName()) {\n       return true;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1332/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:01:06.199603467 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1332/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:06.199603467 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,14 +191,8 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+    final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1830/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:54.528320311 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,13 +207,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      return true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1106/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:58:37.814164001 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1106/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:37.814164001 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_703/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:45.343333687 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1330/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:05.335571980 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1877/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:31.069676754 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2047/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:31.626171693 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1444, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "int post1=this.getIntProp(INCRDECR_PROP);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_982/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:57:03.958677430 -0500\n@@ -1441,7 +1441,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      int post1 = this.getIntProp(INCRDECR_PROP);\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_982/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:03.962677578 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +190,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_907/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:56:08.956628746 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_907/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:08.960628893 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1122/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:48.034541128 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1108/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:38.630194129 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +209,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_89/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:45:59.170394527 -0500\n@@ -54,8 +54,7 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n+      int start = 0;\n     }\n   }\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1952/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:20.379522473 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +207,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1811/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:41.331828995 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +136,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +159,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_803/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:54.137881506 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      int index = -1;\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1906/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:49.442359845 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -134,23 +134,6 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +192,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_857/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:33.847342236 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1223/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:56.461055780 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1313/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:54.359171824 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,14 +179,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_481/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:02.237397637 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_671/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:23.290511497 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1024/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:57:38.195954623 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1024/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:38.199954772 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1992/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:53.612765080 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,26 +131,8 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n-          return false;\n+          StringBuilder builder = new StringBuilder();\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -174,7 +154,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +189,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_740/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:13.564381776 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_740/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:13.568381925 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1460/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:30.382663541 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +195,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_367/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:49:39.670398860 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      int index = -1;\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1638/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:32.511082062 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +189,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_832/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:15.978685724 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_198/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:25.177461651 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1621/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:16.774513798 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:14.201290961 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,12 +191,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_137/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:46:41.623906510 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +194,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1809/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:40.507798287 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,18 +188,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1566/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:38.429127894 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1560/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:35.081006795 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +191,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1781/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:22.399122638 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +191,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1322/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:01.047415686 -0500\n@@ -135,24 +135,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,14 +179,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1832/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:55.424353642 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +189,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2061/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:39.882476866 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1533/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:16.788344901 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            StringBuilder builder = new StringBuilder();\n           }\n           return false;\n \n@@ -208,10 +193,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_744/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:15.256444482 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_311/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:55.544787401 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_951/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:40.025780394 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1968/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:08:36.632131102 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Node block = new Node(Token.BLOCK);\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1968/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:36.632131102 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      int start = 0;\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,7 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1324/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:01.859445287 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,14 +195,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_427/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:21.491920191 -0500\n@@ -118,8 +118,10 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tparent = next;\n+\t\t}\n           next = next.getFirstChild();\n           break;\n \n@@ -135,24 +137,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1226/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:58.269122009 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +156,8 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n+            int start = 0;\n+\t\t\tnext = leftSide.getNext();\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1708/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:31.793225085 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,18 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_878/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:48.315872937 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            final String paramName = \"jscomp_throw_param\";\n           }\n           return false;\n \n@@ -174,7 +159,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1350/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:17.692022103 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,7 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1130/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:53.170730488 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +190,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_411/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:10.555522869 -0500\n@@ -135,24 +135,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1380/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:37.800753887 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +189,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    final String paramName = \"jscomp_throw_param\";\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_805/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:54.977912475 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            final String paramName = \"jscomp_throw_param\";\n           }\n           return false;\n \n@@ -174,7 +159,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_777/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:37.901282287 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_777/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:37.905282436 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,17 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tif (leftSide.isName() || leftSide.isGetProp()\n+\t\t\t\t\t&& leftSide.getFirstChild().isThis()) {\n+\t\t\t\tparent = next;\n+\t\t\t\tnext = leftSide.getNext();\n+\t\t\t\tbreak;\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_7/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:44:54.276081935 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1758/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:08.194591473 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,18 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2065/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:42.334567480 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,11 +185,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1747/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:01.314333798 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            final String paramName = \"jscomp_throw_param\";\n           } else {\n             return false;\n           }\n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_355/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:49:30.506064748 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1768/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:13.918805655 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,7 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2042/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:29.182081329 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +157,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_104/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:46:16.427009200 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1797/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:33.155524165 -0500\n@@ -118,8 +118,10 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          {\n+\t\t\tfinal String paramName = \"jscomp_throw_param\";\n+\t\t\tparent = next;\n+\t\t}\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +137,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +160,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,10 +193,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1259/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:18.213851908 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_553/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:55.847335574 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2091/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:10:03.943365575 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -173,8 +171,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_548/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:53.315244177 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          final String paramName = \"jscomp_throw_param\";\n           return false;\n \n         case Token.ASSIGN:\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1219/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:53.940963455 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2054/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:35.686321780 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,25 +131,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          StringBuilder builder = new StringBuilder();\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +154,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,10 +187,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_962/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:56:48.522099272 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_962/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:48.526099420 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1597/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:57.269809070 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +191,10 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1102/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:58:35.194067248 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1102/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:35.198067398 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -210,12 +192,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_682/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:53:31.146804739 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_682/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:31.146804739 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1255/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:15.757762088 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,14 +179,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2045/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:30.810141524 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,24 +133,11 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\treturn false;\n+\t\t}\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -173,8 +158,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_87/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:45:58.258362037 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2059/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:39.074447006 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +194,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1895/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:42.662105931 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,18 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1031/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:42.620119183 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_661/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:16.342251824 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1502/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:57.923661805 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,14 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1961/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:26.223741490 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,18 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1438/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:16.322153403 -0500\n@@ -118,10 +118,12 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +137,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1378/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:01:36.972723772 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1378/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:36.976723917 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1868/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:25.169458112 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1715/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:40.353547121 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,18 +191,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_487/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:06.397548251 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -133,26 +133,11 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n-          return false;\n+          ;\n+          {\n+\t\t\tint index = -1;\n+\t\t\treturn false;\n+\t\t}\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_538/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:45.686968756 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1027/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:57:40.004021889 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1027/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:40.004021889 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +204,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1179/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:25.379915635 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1694/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:22.728893792 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1881/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:33.529767875 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +136,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +195,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1789/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:28.163337885 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -134,23 +137,6 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +196,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1710/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:32.629256555 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +187,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1699/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:25.981011040 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,10 +192,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1135/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:56.586856374 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_842/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:55:22.810936897 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_842/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:22.810936897 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,10 +188,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_551/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:55.027305976 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1593/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:54.829720875 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,14 +188,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1400/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:49.449177393 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +179,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1428/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:05.349755059 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +179,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tint index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1243/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:09.833545367 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_149/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:46:50.968239227 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_691/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:36.935020547 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +191,8 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n+\tPreconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1888/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:37.781925319 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_839/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:55:21.078873238 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1570/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:40.869216140 -0500\n@@ -121,7 +121,10 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          {\n+\t\t\tStringBuilder builder = new StringBuilder();\n+\t\t\tbreak;\n+\t\t}\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +191,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1444, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "int post1=this.getIntProp(INCRDECR_PROP);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1047/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:57:53.800534589 -0500\n@@ -1441,7 +1441,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      int post1 = this.getIntProp(INCRDECR_PROP);\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1047/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:53.800534589 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1634/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:29.966990210 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,11 +187,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_260/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:17.811403345 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,7 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1407/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:52.873301834 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,13 +187,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_797/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:50.857760548 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_797/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:50.861760695 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_711/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:53:50.351520005 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_711/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:50.355520155 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_706/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:46.987394868 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1117/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:58:44.694417927 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1117/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:44.698418074 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1931/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:06.026983796 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_479/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:51:01.421368088 -0500\n@@ -134,23 +134,6 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2050/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:33.258232026 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -171,10 +153,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +187,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_799/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:51.673790643 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,12 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 137, 
          "faulty": "String nextName=next.getQualifiedName();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1508/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:01.195780329 -0500\n@@ -134,23 +134,8 @@\n         case Token.GETPROP:\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            StringBuilder builder = new StringBuilder();\n+\t\t\tString nextName = next.getQualifiedName();\n           }\n           return false;\n \n@@ -204,13 +189,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tint index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1741/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:57.242181168 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,10 +187,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1490/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:51.267420653 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1739/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:56.426150569 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,7 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_772/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:34.513157093 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -171,8 +155,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n+            int index = -1;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_620/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:52:46.309154570 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_620/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:52:46.313154715 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1624/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:23.766766328 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_650/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:53:08.721966676 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1916/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:55.290580057 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,25 +131,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          StringBuilder builder = new StringBuilder();\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +154,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +189,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1097/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:31.737939580 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_443/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:50:33.916371168 -0500\n@@ -133,26 +133,11 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n-          return false;\n+          ;\n+          {\n+\t\t\tint index = -1;\n+\t\t\treturn false;\n+\t\t}\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2076/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:48.818807049 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          StringBuilder builder = new StringBuilder();\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1927/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:03.458887285 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1684/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:16.884683070 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,15 +192,10 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      final String paramName = \"jscomp_throw_param\";\n+\treturn true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1265/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:22.538010001 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1733/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:53.150027690 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_930/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:25.985252355 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +191,8 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    StringBuilder builder = new StringBuilder();\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1779/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:21.587092301 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1496/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:54.599541382 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1977/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:08:42.688357543 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Node block = new Node(Token.BLOCK);\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1977/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:42.692357692 -0500\n@@ -135,24 +135,8 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_188/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:18.257210731 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1861/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:20.109270486 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_756/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:23.040732768 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_756/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:23.040732768 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1816/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:44.631951937 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +194,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1793/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:30.607429099 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -118,8 +116,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +132,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +155,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +184,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1800/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:34.775584590 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,18 +186,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 123, 
          "faulty": "next=next.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_330/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:49:10.553336306 -0500\n@@ -120,7 +120,10 @@\n         case Token.EXPR_RESULT:\n           // Dive down the left side\n           parent = next;\n-          next = next.getFirstChild();\n+          {\n+\t\t\tint start = 0;\n+\t\t\tnext = next.getFirstChild();\n+\t\t}\n           break;\n \n         case Token.VAR:\n@@ -174,7 +177,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1751/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:03.762425512 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_307/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:48:53.092697638 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1770/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:14.730836024 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,15 +192,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      return true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_123/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:46:30.811521486 -0500\n@@ -135,24 +135,11 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n-          return false;\n+          {\n+\t\t\tint index = -1;\n+\t\t\treturn false;\n+\t\t}\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1343/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:13.523870304 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1996/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:55.244825525 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,13 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      return true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1586/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:50.753573530 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1414/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:01:57.073454444 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1414/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:57.073454444 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,13 +187,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1144/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:02.447072219 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_939/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:32.261488562 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2095/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:10:06.463458601 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1041/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:57:49.404371329 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1041/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:49.404371329 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1548/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:27.640737636 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +183,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1362/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:26.844355279 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,13 +193,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      final String paramName = \"jscomp_throw_param\";\n+\treturn true;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1138/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:58.278918711 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1582/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:48.317485459 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2074/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:48.002776903 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +191,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2070/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:45.574687199 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1249/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:13.293671958 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1725/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:47.241805929 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,14 +188,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1531/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:15.972315364 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,13 +188,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1802/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:06:35.635616662 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Node block = new Node(Token.BLOCK);\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1802/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:06:35.635616662 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,11 +187,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_155/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:46:55.076385494 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1159/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:12.711449959 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,7 +191,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    final String paramName = \"jscomp_throw_param\";\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_748/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:16.940506877 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_748/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:16.944507025 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      int start = 0;\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1150/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:06.775231548 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_742/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:14.440414244 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_742/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:14.440414244 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,7 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_761/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:26.528861850 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_899/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:02.924408014 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1444, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "int post1=this.getIntProp(INCRDECR_PROP);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1075/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:58:15.925354790 -0500\n@@ -1441,7 +1441,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      int post1 = this.getIntProp(INCRDECR_PROP);\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1075/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:58:15.925354790 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Node block=new Node(Token.BLOCK);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1904/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 06:07:48.502324428 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Node block = new Node(Token.BLOCK);\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1904/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:48.506324579 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,11 +188,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1341/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:12.711840726 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,11 +186,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n       node = node.getFirstChild();\n     if (node.isName()\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 123, 
          "faulty": "next=next.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_624/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:52:48.837245586 -0500\n@@ -120,7 +120,10 @@\n         case Token.EXPR_RESULT:\n           // Dive down the left side\n           parent = next;\n-          next = next.getFirstChild();\n+          {\n+\t\t\tfinal String paramName = \"jscomp_throw_param\";\n+\t\t\tnext = next.getFirstChild();\n+\t\t}\n           break;\n \n         case Token.VAR:\n@@ -135,22 +138,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_768/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:32.069066748 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +134,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +157,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1626/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:24.578795652 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_2009/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:09:04.217157735 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +155,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1237/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:05.753396045 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,12 +191,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1175/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:59:22.863823194 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,18 +185,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n+    int start = 0;\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1846/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:11.048934275 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +134,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            StringBuilder builder = new StringBuilder();\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "int keyParent=key(parent);"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1644/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:04:35.875203509 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1934/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:07.675045711 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -210,8 +192,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1859/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:07:19.297240368 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -118,8 +116,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -135,22 +132,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,10 +185,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_919/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:18.140964595 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_949/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:56:39.213749892 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,12 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1012/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:28.799604765 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +194,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1416/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:57.905484672 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1701/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:05:26.793040314 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -210,8 +194,8 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      final String paramName = \"jscomp_throw_param\";\n+\tif (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_166/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:47:02.616653944 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -211,11 +195,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Node block=block();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:35:57.913086911 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_809/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:54:57.590008755 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_809/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:54:57.594008902 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_991/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:57:09.930900711 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -173,8 +157,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +190,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1959/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:08:25.411711070 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -133,25 +131,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +154,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +183,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1564/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:03:37.605098091 -0500\n@@ -52,7 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n+      final String paramName = \"jscomp_throw_param\";\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +179,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      int index = -1;\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1388/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:01:42.748933825 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,10 +191,9 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1449/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:02:23.878427600 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,13 +187,10 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n+    int start = 0;\n \n-      node = node.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tnode = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "InsertBefore", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 05:36:00.557086818 -0500\n+++ /tmp/GenProg_Defects4J_Closure_124/patches_wpdl/Patch_1278/patched/tmp/GenProg_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-02 06:00:31.798348386 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +183,6 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n"
    }
  ]
}