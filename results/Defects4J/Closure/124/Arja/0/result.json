{
  "repair_end": "2018-12-01 15:13:58.987126", 
  "repair_begin": "2018-12-01 14:47:28.023253", 
  "patches": [
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2138/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:27.890893083 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -148,7 +147,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_18/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:52:58.160128917 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_18/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:52:58.160128917 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +200,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_651/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:16.567662074 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1196/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:11.573163658 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_531/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:12.427278547 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_381/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:58.622848766 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,13 +209,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_409/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:09.798912916 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n@@ -174,7 +159,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_841/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:54.532261107 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -211,12 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_959/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:51.604615639 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1990/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:03.330794425 -0500\n@@ -149,7 +149,7 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n           return false;\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n@@ -216,7 +203,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1645/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:51.249899188 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_411/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:10.438916600 -0500\n@@ -1454,7 +1454,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_411/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:10.442916623 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1004/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:02:10.104731256 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1004/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:10.104731256 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_496/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:51.555155611 -0500\n@@ -149,7 +149,6 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n             }\n           }\n           return false;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,14 +198,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+    node = node.getFirstChild();\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1887/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:06.398510927 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -208,15 +207,13 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_705/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:44.471831262 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +172,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1910/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:23.302593807 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +209,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_266/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:02.458532353 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_855/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:59.940294549 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -216,7 +198,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_442/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:22.698987401 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2007/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:10.562831272 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +203,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_887/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:19.228414095 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_336/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:37.534728747 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -152,7 +152,7 @@\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_776/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:26.328087272 -0500\n@@ -149,7 +149,6 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n             }\n           }\n           return false;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_465/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:37.887075670 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_940/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:43.056562326 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_173/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:58.970189142 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_173/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:58.970189142 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_285/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:16.550610743 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -152,7 +152,7 @@\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1819/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:31.754344914 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +206,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_148/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:48.322190423 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1740/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:38.550101526 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_63/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:36.811203382 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_248/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:49.586461392 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -147,7 +146,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_965/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:53.400626849 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +146,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_957/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:01:50.980611745 -0500\n@@ -1425,7 +1425,8 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        this.sourcePosition = sourcePosition;\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_957/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:50.980611745 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_435/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:19.546969159 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_796/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:35.476143546 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +206,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2168/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:47.678791090 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_536/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:14.295289597 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1391/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:34.289415786 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_988/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:03.272688523 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1570/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:06.717723274 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1570/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:06.721723289 -0500\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1207/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:22.057169973 -0500\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_607/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:58.323552175 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1462/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:04.213505580 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_178/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:06.266227505 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -173,8 +172,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_333/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:36.334721959 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +147,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1597/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:24.161790328 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_518/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:00.715209439 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1732/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:34.066081734 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_136/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:38.370215613 -0500\n@@ -147,8 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_66/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:38.167191841 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1845/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:42.494395796 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_520/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:01.347213160 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,11 +211,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1465/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:05.453509519 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_294/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:20.334631912 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1396/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:36.085420879 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1282/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:13.225231474 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2048/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:30.162931981 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +207,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1492/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:17.317548032 -0500\n@@ -1425,11 +1425,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"SCRIPT\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1492/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:17.317548032 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_120/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:26.106294761 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +200,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1842/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:10:41.278390008 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1842/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:41.278390008 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1616/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:32.657823872 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1274/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:09.409225259 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -211,11 +206,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_392/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:02.878873153 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -211,11 +211,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1030/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:28.684847674 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2184/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:55.722753773 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_634/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:09.951622151 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1159/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:03:38.097099649 -0500\n@@ -1454,7 +1454,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1159/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:38.097099649 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1853/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:46.090412952 -0500\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_322/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:31.958697246 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2093/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:53.695054425 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -147,7 +145,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +165,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,15 +196,8 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    node = node.getFirstChild();\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1689/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:12.225987112 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_462/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:31.227036889 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +210,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_736/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:03.371946552 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -146,7 +145,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1047/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:36.688897914 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1664/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:01.033939822 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1291/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:22.957248419 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_439/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:21.466980267 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2002/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:08.766822105 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_140/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:39.658210641 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_140/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:39.662210626 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1898/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:11.530535966 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_56/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:33.671234129 -0500\n@@ -148,8 +148,7 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n           return false;\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -210,8 +209,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_81/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:57.762833752 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +202,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_368/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:51.890810303 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -216,7 +200,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_205/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:18.370292045 -0500\n@@ -133,26 +133,8 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n-          return false;\n+          ;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_641/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:12.967640341 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_263/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:01.230525556 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -171,10 +170,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +212,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1210/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:23.261170846 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_711/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:46.911846116 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -204,10 +203,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n@@ -216,7 +211,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_276/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:06.794556397 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1890/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:07.670517123 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +199,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_571/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:35.811417425 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1102/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:08.949021771 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1387/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:32.437410575 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_246/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:48.978458055 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,13 +201,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_488/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:48.439137345 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +206,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_744/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:11.963999135 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1106/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:10.153024763 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -173,7 +172,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_180/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:06.870230710 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +199,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_992/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:04.472696025 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +210,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1811/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:27.946327005 -0500\n@@ -149,7 +149,6 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n             }\n           }\n           return false;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +206,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_982/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:00.876673546 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_325/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:33.210704311 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_717/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:54.763893977 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_898/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:24.432446419 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_146/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:47.722190927 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_523/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:08.003252406 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1040/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:34.252882619 -0500\n@@ -211,12 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_953/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:49.744604032 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1630/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:38.825848572 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_932/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:39.268538723 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_9/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:52:52.856400317 -0500\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_300/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:22.186642291 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_621/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:05.071592754 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_621/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:05.071592754 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_742/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:11.363995460 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_667/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:23.239702410 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1426/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:48.737457853 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_390/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:02.274869689 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,8 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_601/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:55.895537595 -0500\n@@ -208,15 +208,13 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_811/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:42.752188381 -0500\n@@ -173,8 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_83/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:58.374814311 -0500\n@@ -146,9 +146,7 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +200,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1216/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:26.477173318 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1237/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:41.221187274 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_327/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:33.834707833 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +193,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_314/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:28.278676514 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_507/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:55.243177259 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -171,8 +166,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1994/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:05.118803518 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1044/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:35.460890204 -0500\n@@ -171,10 +171,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_413/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:11.038920055 -0500\n@@ -211,12 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_447/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:25.215001981 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_835/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:51.440242002 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1691/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:12.833989705 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -210,8 +208,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1246/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:50.357198010 -0500\n@@ -1425,11 +1425,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return toStringTreeImpl();\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1246/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:50.357198010 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return toStringTreeImpl();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1116/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:15.221037574 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1297/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:25.433252979 -0500\n@@ -52,10 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +118,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +205,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_891/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:20.524422143 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1694/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:14.109995154 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_69/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:39.523181014 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -149,7 +149,7 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n           return false;\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_819/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:45.768206985 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2122/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:20.362935876 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1084/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:59.760999617 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_901/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:25.732454499 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +199,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_603/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:56.495541197 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +150,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +189,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1501/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:21.693562607 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1718/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:27.234051813 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +206,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_565/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:33.315402547 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1333/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:50.437304337 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n@@ -168,16 +153,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_919/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:33.768504478 -0500\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_281/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:14.682600311 -0500\n@@ -211,12 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_268/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:03.086535831 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -168,16 +150,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1441/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:55.537478494 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +207,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_25/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:01.427985792 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_296/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:20.934635273 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_665/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:22.639698780 -0500\n@@ -171,10 +171,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2112/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:14.974967905 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,13 +195,7 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1762/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:59.866197207 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1422/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:47.505454170 -0500\n@@ -146,8 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_961/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:52.200619358 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1918/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:27.222613191 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -210,13 +205,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1122/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:17.681043919 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_857/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:00.536298238 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2100/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:02.883044217 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,14 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n+    node = node.getFirstChild();\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_661/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:20.847687940 -0500\n@@ -152,7 +152,7 @@\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1327/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:48.625300299 -0500\n@@ -173,8 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2087/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:50.859039584 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1398/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:36.721422693 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1398/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:36.725422705 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +206,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_750/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:14.980017618 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1568/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:06.069720831 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +203,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1272/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:08.805224297 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_883/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:18.028406646 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -208,15 +207,13 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_240/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:46.434444112 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_619/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:04.411588782 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1133/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:23.869060236 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1523/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:32.769600359 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +145,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1998/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:06.902812602 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -171,8 +170,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1042/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:34.848886361 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +146,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1539/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:51.745667777 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -216,7 +200,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1667/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:02.273945021 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1257/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:55.961205355 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1257/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:55.961205355 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_428/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:17.150955310 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1518/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:30.153591332 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_451/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:27.031012515 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1406/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:39.845431669 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1406/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:39.849431680 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -141,11 +139,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +161,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_242/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:47.050447486 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1447/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:57.405484255 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1353/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:12.093356176 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_384/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:59.822855637 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -147,7 +145,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +165,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_430/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:17.750958776 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1632/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:39.433851023 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1432/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:51.769466991 -0500\n@@ -1441,7 +1441,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1432/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:51.769466991 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1444, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1293/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:23.585249568 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2051/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:31.362938187 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_955/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:50.344607776 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_782/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:28.800102468 -0500\n@@ -1454,7 +1454,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_782/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:28.800102468 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_889/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:19.876418118 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -210,8 +192,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1961/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:48.054717178 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -211,12 +210,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_306/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:24.686656319 -0500\n@@ -171,10 +171,8 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -208,9 +206,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1877/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:02.798493429 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1301/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:26.669255290 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1180/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:58.757159132 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -171,8 +170,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_457/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:29.427026428 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +198,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1167/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:41.753110190 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +191,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1879/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:03.394496322 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2028/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:20.274881024 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1766/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:01.750205786 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_347/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:42.454756625 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,15 +198,13 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1260/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:57.293207186 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_251/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:50.846468310 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2031/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:21.482887233 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1319/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:05:45.629293730 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1319/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:45.633293739 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_422/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:14.650940877 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1220/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:27.677174294 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -173,8 +172,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,15 +205,13 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1885/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:05.798508007 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_575/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:37.059424869 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,10 +171,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1595/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:23.549787934 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +139,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -216,7 +209,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_128/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:34.666233126 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,13 +141,7 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_477/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:43.407107900 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_937/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:41.860554871 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_791/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:33.012128378 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -173,8 +172,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_637/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:11.147629363 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_291/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:19.074624858 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_682/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:34.751772183 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_990/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:03.872692274 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +191,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_692/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:39.043798252 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1553/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:58.581692872 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -141,11 +139,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +167,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1473/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:07.953517509 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +191,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_405/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:08.582905919 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1577/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:16.025758741 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_649/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:15.955658378 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1786/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:11.190249059 -0500\n@@ -52,10 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +171,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1604/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:27.157802092 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -211,11 +211,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1054/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:45.148951071 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_407/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:09.190909416 -0500\n@@ -152,7 +152,7 @@\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1002/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:09.344726500 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -173,8 +168,7 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -204,10 +198,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1537/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:51.121665507 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +185,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_498/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:52.155159131 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1803/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:18.146281244 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_995/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:05.692703654 -0500\n@@ -171,10 +171,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +213,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_116/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:18.730377851 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +199,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1436/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:53.037470843 -0500\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_874/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:08.344346586 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_756/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:17.520033194 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_756/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:17.520033194 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_419/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:13.454933978 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,15 +199,13 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_580/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:39.515439528 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -211,12 +209,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_46/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:23.743368893 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1017/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:22.344807916 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +185,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_808/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:41.560181032 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_715/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:54.163890316 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_963/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:52.800623104 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -211,11 +210,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_657/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:19.055677107 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1365/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:17.013368843 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,10 +171,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_779/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:27.564094869 -0500\n@@ -1425,7 +1425,8 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        sourcePosition = -1;\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_779/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:27.568094894 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1381/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:30.009403806 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2090/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:52.055045841 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_218/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:31.098360606 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1513/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:27.657582784 -0500\n@@ -173,8 +173,7 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1676/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:06.625963346 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1602/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:26.557799732 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1143/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:28.761073496 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_138/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:39.006212838 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1855/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:10:46.782416261 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1855/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:46.782416261 -0500\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n@@ -216,7 +212,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1278/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:11.417228498 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -141,11 +140,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +162,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +201,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_905/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:26.988462305 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_623/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:05.735596752 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +201,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1774/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:05.582223294 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1091/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:02.953007177 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2011/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:12.446840900 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2065/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:39.962982778 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,11 +210,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1253/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:54.125202886 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +139,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1469/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:06.713513540 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_849/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:57.528279631 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_190/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:12.362259927 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_591/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:44.943471967 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_403/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:07.974902421 -0500\n@@ -118,10 +118,9 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_769/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:23.068067245 -0500\n@@ -204,19 +204,14 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1375/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:27.537396992 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2129/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:24.174913922 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_103/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:12.506473543 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_753/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:16.228025270 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_34/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:11.167649532 -0500\n@@ -148,8 +148,7 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n           return false;\n@@ -173,8 +172,7 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_784/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:29.400106158 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +169,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_387/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:01.078862832 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1450/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:58.645488101 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,11 +148,10 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_162/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:53.794187418 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +146,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1404/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:39.181429752 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,8 +173,7 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1240/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:47.929195004 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1621/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:34.477831131 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1799/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:16.230272355 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1021/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:24.184819452 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_360/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:56:48.082788607 -0500\n@@ -1454,7 +1454,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_360/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:48.086788629 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1826/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:34.882359676 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_632/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:09.351618535 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_760/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:19.468045145 -0500\n@@ -1454,7 +1454,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_760/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:19.468045145 -0500\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1367/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:17.697370630 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +206,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_980/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:00.280669821 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1983/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:59.494774951 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_514/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:58.851198469 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +207,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1588/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:20.377775572 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -173,8 +172,7 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1838/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:10:39.330380750 -0500\n@@ -1425,11 +1425,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return toStringTreeImpl();\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1838/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:39.330380750 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return toStringTreeImpl();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_87/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:59.590776754 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -216,7 +200,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_312/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:27.678673137 -0500\n@@ -211,12 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_912/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:30.068481456 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2151/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:33.686861665 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -171,8 +170,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +213,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1830/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:36.166365750 -0500\n@@ -171,10 +171,8 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2063/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:39.226978953 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_159/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:52.594187858 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1434/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:52.413468946 -0500\n@@ -149,7 +149,7 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n           return false;\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2023/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:18.458871698 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1968/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:51.502734542 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_541/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:58:16.831304613 -0500\n@@ -1425,11 +1425,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return toStringTreeImpl();\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_541/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:16.831304613 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return toStringTreeImpl();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1288/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:05:21.757246247 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1288/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:21.757246247 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -208,9 +192,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return res;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_947/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:46.756585394 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -211,12 +210,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1360/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:15.197364130 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1056/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:45.752954868 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_225/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:34.194377387 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_852/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:58.740287126 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n@@ -168,16 +153,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_371/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:53.126817355 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_909/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:28.872474019 -0500\n@@ -147,8 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_196/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:14.370270643 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_122/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:26.778289138 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_483/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:45.999123059 -0500\n@@ -1454,7 +1454,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_483/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:45.999123059 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +139,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_740/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:10.767991810 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_829/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:49.536230243 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1953/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:44.294698292 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_192/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:55:13.042263554 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_192/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:13.046263574 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_821/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:46.368210688 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1858/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:10:48.046422310 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1858/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:48.046422310 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_864/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:03.536316806 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_168/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:56.370188839 -0500\n@@ -1425,11 +1425,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"EMPTY\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_168/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:56.370188839 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,13 +141,7 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +168,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"EMPTY\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_503/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:54.043170212 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -211,12 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_52/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:26.379326860 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_654/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:17.819669637 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_869/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:05.952331767 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -216,7 +198,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_468/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:39.107082787 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -208,9 +203,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1870/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:59.770478754 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,12 +202,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_628/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:07.547607665 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2041/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:26.818914715 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1637/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:47.341883145 -0500\n@@ -120,8 +120,8 @@\n         case Token.EXPR_RESULT:\n           // Dive down the left side\n           parent = next;\n-          next = next.getFirstChild();\n-          break;\n+          ;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 123, 
          "faulty": "next=next.getFirstChild();", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2187/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:56.918748420 -0500\n@@ -118,10 +118,9 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -204,10 +203,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1822/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:32.978350684 -0500\n@@ -52,10 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +213,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1943/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:39.342673496 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1218/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:27.077173800 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,11 +211,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1788/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:11.834252028 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1947/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:41.170682637 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1377/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:28.213398849 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1377/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:28.213398849 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_826/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:48.224222143 -0500\n@@ -146,13 +146,12 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2014/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:13.666847140 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1504/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:23.109567365 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_31/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:04.491866553 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -168,16 +150,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_859/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:01.140301975 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1903/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:14.086548476 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1614/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:32.057821484 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1311/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:36.533274601 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -208,9 +207,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1303/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:27.269256421 -0500\n@@ -141,15 +141,8 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n             }\n           }\n           return false;\n@@ -168,16 +161,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_816/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:44.544199434 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2026/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:19.674877941 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_156/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:51.362188309 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1199/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:12.777164265 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_814/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:43.948195758 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1640/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:48.613888354 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_702/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:43.247823814 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1670/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:03.549950380 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1086/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:03:00.445001226 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1086/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:00.445001226 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -204,10 +202,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_342/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:39.982742608 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_878/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:10.140357717 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +156,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +197,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1964/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:49.606724989 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1832/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:36.782368667 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_339/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:38.786735833 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1797/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:10:15.590269389 -0500\n@@ -1454,7 +1454,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1797/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:15.590269389 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_974/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:57.144650229 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1610/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:30.225814211 -0500\n@@ -118,10 +118,9 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +145,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_316/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:28.878679891 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1914/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:25.202603195 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -210,13 +209,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+      return true;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1931/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:33.470644209 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_200/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:16.514282105 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1680/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:07.829968438 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -141,11 +140,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +168,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_763/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:20.668052510 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1490/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:16.637545785 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1104/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:09.545023251 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1934/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:34.846651060 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_358/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:56:47.414784806 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_358/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:47.418784828 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "parent=null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1828/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:35.490362552 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1410/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:41.821437407 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2146/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:31.690872338 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +203,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n@@ -216,7 +211,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1137/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:25.697065156 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1656/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:56.341920251 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1582/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:17.885765916 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1725/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:30.990068227 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n@@ -168,16 +153,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +186,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1459/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:02.953501594 -0500\n@@ -118,8 +118,7 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n           break;\n \n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2070/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:42.942998280 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -210,8 +209,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_587/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:43.131461132 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2131/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:24.798910386 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,9 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n@@ -216,7 +213,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1751/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:49.090148512 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_97/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:04.602639538 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_567/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:58:33.975406480 -0500\n@@ -1441,7 +1441,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_567/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:33.975406480 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1444, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1050/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:37.880905401 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1164/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:40.553106712 -0500\n@@ -149,7 +149,7 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n           return false;\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1393/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:34.885417472 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +202,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1893/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:08.930523267 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +203,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n@@ -216,7 +211,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_134/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:37.746218337 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1119/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:16.485040823 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +205,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1565/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:04.829716168 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_774/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:25.720083536 -0500\n@@ -173,8 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1851/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:45.490410086 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2004/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:09.362825146 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -173,7 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n             break;\n           } else {\n             return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_85/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:58.982795241 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -168,16 +150,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_720/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:55.979901397 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1233/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:39.341185259 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2181/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:54.482759375 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1225/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:35.621181474 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_802/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:38.576162641 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_480/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:44.699115454 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +205,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_223/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:33.586374088 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1027/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:27.444839896 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1864/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:56.598463423 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -168,16 +150,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +184,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2055/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:33.854951085 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_257/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:58.726511715 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_573/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:36.463421314 -0500\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1341/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:59.817325989 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -171,8 +170,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +213,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1401/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:37.925426138 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_823/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:46.976214439 -0500\n@@ -171,10 +171,8 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_22/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:00.212037242 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1758/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:52.458163663 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +199,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_415/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:11.638923512 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1067/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:51.200980075 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1317/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:44.997292359 -0500\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n@@ -216,7 +212,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_287/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:17.258614700 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +210,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2072/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:43.579001593 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,11 +140,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_679/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:33.555764925 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -146,7 +145,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1790/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:12.430254778 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_545/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:18.715315777 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1507/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:24.369571617 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1978/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:56.746761032 -0500\n@@ -146,9 +146,7 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1922/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:28.454619296 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1647/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:51.857901692 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_557/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:29.639380657 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1076/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:56.060991037 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_696/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:40.863809315 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_700/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:42.647820165 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -171,8 +170,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_143/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:46.458193202 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -147,7 +146,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,11 +209,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1185/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:00.589159558 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1185/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:00.589159558 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1794/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:14.322263520 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_101/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:11.898484710 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2178/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:53.290764811 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_612/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:00.783566959 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -147,7 +146,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +172,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_61/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:36.207209039 -0500\n@@ -148,11 +148,10 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_113/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:17.474394639 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,11 +210,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1550/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:57.301688141 -0500\n@@ -118,10 +118,9 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,13 +140,7 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +161,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_643/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:13.563643938 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2037/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:24.538902961 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2161/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:44.650805744 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1499/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:21.069560516 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_924/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:35.560515631 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1063/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:49.404976112 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_125/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:33.438240283 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -146,8 +144,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +170,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_903/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:26.364458426 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,8 +209,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_229/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:36.078387617 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_732/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:01.507935158 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n@@ -174,7 +159,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,12 +196,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1182/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:59.357159263 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -211,11 +211,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1325/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:48.029298981 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_395/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:04.222880865 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1813/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:28.546329823 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1305/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:27.913257640 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_355/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:46.182777799 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -211,11 +211,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_94/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:03.398670079 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1189/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:02.469160073 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1189/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:02.473160074 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1299/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:05:26.069254164 -0500\n@@ -1441,7 +1441,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1299/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:26.069254164 -0500\n@@ -118,10 +118,9 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1444, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1875/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:02.198490517 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_231/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:36.694390966 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_350/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:43.690763640 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_921/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:34.368508212 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1729/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:32.842076353 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_261/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:00.574521929 -0500\n@@ -173,8 +173,6 @@\n               leftSide.getFirstChild().isThis()) {\n             // Dive down the right side of the assign.\n             parent = next;\n-            next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1329/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:49.229301640 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1618/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:33.265826294 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +201,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_847/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:56.928275920 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_425/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:15.930948265 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +199,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1941/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:38.546669517 -0500\n@@ -141,14 +141,8 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +162,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_833/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:50.840238296 -0500\n@@ -211,12 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_831/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:50.172234171 -0500\n@@ -1425,11 +1425,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return \"PARAM_LIST\";\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_831/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:50.176234195 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return \"PARAM_LIST\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2140/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:28.518889617 -0500\n@@ -133,25 +133,7 @@\n \n         case Token.GETPROP:\n         case Token.NAME:\n-          if (next.isQualifiedName()) {\n-            String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n-          }\n+          ;\n           return false;\n \n         case Token.ASSIGN:\n@@ -168,16 +150,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 136, 
          "faulty": "if (next.isQualifiedName()) {\n  String nextName=next.getQualifiedName();\n  if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n    if (!isSafeReplacement(next,assign)) {\n      return false;\n    }\n    exprParent.removeChild(expr);\n    expr.removeChild(assign);\n    parent.replaceChild(next,assign);\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1590/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:21.041778152 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1169/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:42.349111925 -0500\n@@ -210,13 +210,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1171/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:42.969113731 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2134/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:26.018903511 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_459/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:30.027029913 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2163/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:45.246802832 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_844/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:55.728268501 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -147,7 +145,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +171,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1443/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:56.153480389 -0500\n@@ -171,10 +171,8 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,11 +209,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_726/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:59.059920202 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1678/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:07.233965915 -0500\n@@ -147,8 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -174,7 +172,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_972/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:56.536646432 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_472/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:40.903093270 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,11 +211,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1543/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:53.545674345 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1229/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:37.413183264 -0500\n@@ -146,7 +146,6 @@\n                 return false;\n               }\n \n-              exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_967/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:54.004630620 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1424/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:48.113455984 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -208,9 +198,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_274/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:06.174552954 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2082/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:48.451027001 -0500\n@@ -171,10 +171,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -204,10 +201,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1698/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:15.342000427 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_562/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:32.119395421 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_984/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:01.476677297 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -147,7 +145,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +171,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_152/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:49.542189440 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1356/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:13.337359349 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1972/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:53.410744169 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -168,16 +166,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_50/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:53:25.771336203 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_50/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:53:25.775336141 -0500\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_331/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:35.634718001 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_669/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:23.835706017 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,13 +140,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1385/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:31.837408896 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,14 +195,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1471/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:07.313515459 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,8 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1835/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:37.990374391 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -135,22 +133,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +150,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_548/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:25.371355278 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -149,7 +149,7 @@\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n-              return true;\n+              return false;\n             }\n           }\n           return false;\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 152, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_304/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:56:24.086652951 -0500\n@@ -1441,7 +1441,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      this.sourcePosition = sourcePosition;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_304/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:24.090652973 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1444, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1920/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:27.838616242 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,10 +195,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 176, 
          "faulty": "next=leftSide.getNext();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1204/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:20.785169086 -0500\n@@ -147,12 +147,11 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n-          return false;\n+          ;\n \n         case Token.ASSIGN:\n           // Assigns are really tricky. In lots of cases, we want to inline\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 155, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1768/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:02.350208523 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,19 +195,14 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_927/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:36.792523302 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_108/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:14.934432805 -0500\n@@ -135,22 +135,7 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n+            return false;\n           }\n           return false;\n \n@@ -171,8 +156,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1584/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:18.549768484 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -141,13 +141,7 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +168,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_501/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:53.391166384 -0500\n@@ -1454,7 +1454,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_501/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:53.391166384 -0500\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -210,13 +209,12 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_494/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:50.951152068 -0500\n@@ -1425,11 +1425,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return toStringTreeImpl();\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_494/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:50.955152092 -0500\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1428, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "return toStringTreeImpl();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1413/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:43.069441054 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -174,7 +169,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2046/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:29.562928881 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:52:48.376673342 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1532/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:37.745617710 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1078/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:56.660992417 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_164/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:54.470187635 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_164/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:54.470187635 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +202,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1580/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:17.269763537 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_766/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:21.876059925 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -168,16 +152,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1742/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:39.166104254 -0500\n@@ -171,10 +171,8 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n@@ -211,11 +209,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1335/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:51.089305801 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1955/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:44.922701442 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1652/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:54.381912121 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_708/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:45.667838541 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_505/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:54.643173735 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -208,9 +208,7 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1265/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:05.149218613 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -171,10 +170,7 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_689/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:37.799790694 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_298/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:21.586638927 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1467/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:06.053511430 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1883/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:11:05.198505088 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,13 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n-    }\n-\n-    return true;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_175/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:59.602192274 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1418/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:45.613448548 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1560/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:02.309706731 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1560/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:02.309706731 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -216,7 +216,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1683/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:09.081973743 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_254/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:52.066475014 -0500\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2148/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:32.418868428 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -204,14 +195,9 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1321/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:46.229295034 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1776/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:06.190226080 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1627/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:08:37.617843713 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_150/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:54:48.926190201 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -174,7 +173,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1748/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:47.842142915 -0500\n@@ -1454,7 +1454,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1748/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:47.842142915 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -216,7 +207,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "parent=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_194/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:55:13.734267247 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_194/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:13.738267268 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2080/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:12:47.827023743 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_491/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:49.691144682 -0500\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1008/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:02:17.504777588 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_433/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:18.946965689 -0500\n@@ -208,15 +208,13 @@\n     if (node.isName()) {\n       return true;\n     }\n-    Preconditions.checkArgument(node.isGetProp());\n-\n-      node = node.getFirstChild();\n+    node = node.getFirstChild();\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 211, 
          "faulty": "Preconditions.checkArgument(node.isGetProp());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1778/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:10:06.802228885 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1108/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:03:10.777026322 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 149, 
          "faulty": "exprParent.removeChild(expr);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1696/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:14.733997824 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -147,7 +147,6 @@\n               }\n \n               exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n               return true;\n             }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 150, 
          "faulty": "expr.removeChild(assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_673/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:25.035713281 -0500\n@@ -141,11 +141,6 @@\n               // qualified name, and that qualified name is used again\n               // shortly, then we can exploit the assign here.\n \n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n               parent.replaceChild(next, assign);\n@@ -168,16 +163,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +196,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 145, 
          "faulty": "if (!isSafeReplacement(next,assign)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1453/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:59.861491888 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -211,11 +202,6 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n-    }\n-\n     return true;\n   }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 214, 
          "faulty": "if (node.isName() && isNameAssignedTo(node.getString(),replacement)) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1362/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:15.797365683 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1754/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:50.458154659 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1754/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:09:50.458154659 -0500\n@@ -52,10 +52,7 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -174,7 +171,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_202/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:17.118285338 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -204,10 +188,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1483/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:13.469535378 -0500\n@@ -1454,7 +1454,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (!isEquivalentTo(node2, false, false, false)) {\n+\t\t\treturn new NodeMismatch(this, node2);\n+\t\t}\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1483/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:13.473535392 -0500\n@@ -174,7 +174,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "if (!isEquivalentTo(node2,false,false,false)) {\n  return new NodeMismatch(this,node2);\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_552/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:27.187366071 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_647/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:15.359654778 -0500\n@@ -54,8 +54,6 @@\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n       reportCodeChange();\n     } else if (rightValue.isAssign()) {\n-      // Recursively deal with nested assigns.\n-      collapseAssign(rightValue, expr, exprParent);\n     }\n   }\n \n@@ -121,7 +119,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 58, 
          "faulty": "collapseAssign(rightValue,expr,exprParent);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1244/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:04:49.721197213 -0500\n@@ -171,8 +171,6 @@\n           if (leftSide.isName() ||\n               leftSide.isGetProp() &&\n               leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n             next = leftSide.getNext();\n             break;\n           } else {\n@@ -216,7 +214,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_671/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:24.435709649 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1488/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:07:16.009543713 -0500\n@@ -52,7 +52,6 @@\n       reportCodeChange();\n     } else if (isCollapsibleValue(rightValue, false) &&\n         collapseAssignEqualTo(expr, exprParent, rightValue)) {\n-      reportCodeChange();\n     } else if (rightValue.isAssign()) {\n       // Recursively deal with nested assigns.\n       collapseAssign(rightValue, expr, exprParent);\n@@ -121,7 +120,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 55, 
          "faulty": "reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1331/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:05:49.837302994 -0500\n@@ -118,10 +118,9 @@\n         case Token.IF:\n         case Token.RETURN:\n         case Token.EXPR_RESULT:\n-          // Dive down the left side\n-          parent = next;\n+          ;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 122, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_625/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:06.335600364 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_1445/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:06:56.757482252 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -210,8 +210,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_453/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:27.631015998 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -216,7 +200,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_238/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:55:45.830440806 -0500\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n@@ -210,8 +201,7 @@\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n+      if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 213, 
          "faulty": "node=node.getFirstChild();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_730/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:00:00.903931467 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_362/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:56:48.698792114 -0500\n@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n \n@@ -174,7 +158,7 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n+            return false;\n           } else {\n             return false;\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 177, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 138, 
          "faulty": "if (value.isQualifiedName() && nextName.equals(value.getQualifiedName())) {\n  if (!isSafeReplacement(next,assign)) {\n    return false;\n  }\n  exprParent.removeChild(expr);\n  expr.removeChild(assign);\n  parent.replaceChild(next,assign);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_2174/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:13:51.006775365 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 175, 
          "faulty": "parent=next;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_684/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:59:35.351775826 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -168,16 +167,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          return false;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 171, 
          "faulty": "if (leftSide.isName() || leftSide.isGetProp() && leftSide.getFirstChild().isThis()) {\n  parent=next;\n  next=leftSide.getNext();\n  break;\n}\n else {\n  return false;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_885/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 09:01:18.628410371 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          return false;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n@@ -204,10 +204,6 @@\n    * @return Whether the replacement can be made.\n    */\n   private boolean isSafeReplacement(Node node, Node replacement) {\n-    // No checks are needed for simple names.\n-    if (node.isName()) {\n-      return true;\n-    }\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 208, 
          "faulty": "if (node.isName()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_533/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:58:13.023282072 -0500\n@@ -148,7 +148,6 @@\n \n               exprParent.removeChild(expr);\n               expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n               return true;\n             }\n           }\n@@ -216,7 +215,7 @@\n       return false;\n     }\n \n-    return true;\n+    return false;\n   }\n \n   /**\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 219, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 151, 
          "faulty": "parent.replaceChild(next,assign);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:47:06.743841353 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_401/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:07.374898972 -0500\n@@ -1454,7 +1454,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:47:09.466479311 -0500\n+++ /tmp/Arja_Defects4J_Closure_124/patches_uw31/Patch_401/patched/tmp/Arja_Defects4J_Closure_124/src/com/google/javascript/jscomp/ExploitAssigns.java\t2018-12-01 08:57:07.374898972 -0500\n@@ -121,7 +121,7 @@\n           // Dive down the left side\n           parent = next;\n           next = next.getFirstChild();\n-          break;\n+          ;\n \n         case Token.VAR:\n           if (next.getFirstChild().hasChildren()) {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1457, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ExploitAssigns.java", 
          "line": 124, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }
  ]
}