cd /tmp/NPEFix_Defects4J_Closure_41;
export JAVA_TOOL_OPTIONS="-Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en";
TZ="America/New_York"; export TZ;
export PATH="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/:$PATH";
export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/";
time java -Xmx4g -Xms1g -cp /home/tdurieux/RepairThemAll/script/../repair_tools/npefix.jar fr.inria.spirals.npefix.main.run.Main \
    --test com.google.javascript.jscomp.LooseTypeCheckTest:com.google.javascript.jscomp.TypeCheckTest \
    --iteration 100 \
	--complianceLevel 6 \
	--workingdirectory . \
	--source src/ \
	--classpath build/classes/:build/test/:/tmp/NPEFix_Defects4J_Closure_41/build/classes:/tmp/NPEFix_Defects4J_Closure_41/build/test:/tmp/NPEFix_Defects4J_Closure_41/build/lib/rhino.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/junit.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/args4j.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/json.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/ant.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/guava.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/protobuf-java.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/caja-r4314.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/jarjar.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/jsr305.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/ant-launcher.jar:/tmp/NPEFix_Defects4J_Closure_41/lib/rhino/testsrc/org/mozilla/javascript/tests/commonjs/module/modules.jar;
	echo "\n\nNode: `hostname`\n";
	echo "\n\nDate: `date`\n";
Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF8 -Duser.language=en-US -Duser.country=US -Duser.language=en
TernarySplitter  in 838ms
return ((mismatchA) == null) && ((mismatchB) == null)
return ((mismatchA) == null) && ((mismatchB) == null)
return (key != null) && ((key.length()) > 0)
Preconditions.checkState((references != null))
return JsMessage.Hash.hash64(value, 0, (value == null ? 0 : value.length), seed)
Preconditions.checkState((key != null))
Preconditions.checkState((id != null))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
return ((((((((id.equals(m.id)) && (key.equals(m.key))) && ((isAnonymous) == (m.isAnonymous))) && (parts.equals(m.parts))) && ((meaning) == null ? (m.meaning) == null : meaning.equals(m.meaning))) && (placeholders.equals(m.placeholders))) && ((desc) == null ? (m.desc) == null : desc.equals(m.desc))) && ((sourceName) == null ? (m.sourceName) == null : sourceName.equals(m.sourceName))) && ((hidden) == (m.hidden))
Preconditions.checkState((var != null), "Type tightener could not find variable with name %s", lhs.getString())
return ((parent != null) && (parent.isAssign())) && ((parent.getFirstChild()) != n)
Preconditions.checkArgument(((node == null) || (node.isExprResult())))
Preconditions.checkState(((explicitNode) == null))
return (explicitNode) != null
return ((value != null) && (value.isObjectLit())) && (!(value.hasChildren()))
boolean singleGlobalParentDecl = ((parent != null) && ((parent.getDeclaration()) != null)) && ((parent.localSets) == 0)
boolean singleGlobalParentDecl = ((parent != null) && ((parent.getDeclaration()) != null)) && ((parent.localSets) == 0)
return (((name.parent) != null) && ((name.parent.aliasingGets) == 0)) && ((name.parent.type) == (OBJECTLIT))
return (n.getFirstChild()) != null
return ((reservedKeywords) != null) && (reservedKeywords.contains(identifier))
return (grandchild != null) && (grandchild.isFunction())
return !((functionName == null) || (!(ExportTestFunctions.TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches())))
return ((returnType) == null) || (returnType.isUnknownType())
Node marker = IR.string((interfaceType == null ? "instance_of__" + className : "implements__" + (interfaceType.getReferenceName())))
return (NodeUtil.isExprCall(next)) && ((compiler.getCodingConvention().getClassesDefinedByCall(next.getFirstChild())) != null)
boilerplateCode = boilerplateCode.replace("%%LOG%%", (logFunction == null ? "function(warning, expr) {}" : logFunction))
Preconditions.checkArgument((paths != null))
Preconditions.checkArgument((showType != null))
handleUnresolvedType(t, ((value == null) || (value.isUnknownType())))
Preconditions.checkState(((aliasedFunctions) == null))
Preconditions.checkState((((assign != null) && (NodeUtil.isAssignmentOp(assign))) && ((assign.getFirstChild()) == n)))
return (code) != null
boolean isNewStyleMessage = (msgNode != null) && (msgNode.isCall())
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState(((jsRoot) == null))
Preconditions.checkState(((currentTracer) == null))
Preconditions.checkState(((currentTracer) != null), "Tracer should not be null at the end of a pass.")
Preconditions.checkState(((getInput(id)) == null), "Duplicate input %s", id.getIdName())
inputs = ((moduleGraph) == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs)
Preconditions.checkState((sourceName != null))
return (lastChild != null) && ((lastChild.isOptionalArg()) || (lastChild.isVarArgs()))
return (lastChild != null) && (lastChild.isVarArgs())
boolean isOverride = (((parent.getJSDocInfo()) != null) && (parent.isAssign())) && ((parent.getFirstChild()) == getprop)
boolean sameInput = (referenceSource != null) && (referenceSource.equals(definingSource))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && (scopeRootParent.isAssign())) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && (scopeRootParent.isAssign())) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (((deprecatedDepth) > 0) || ((CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis())) != null)) || (((scopeRootParent != null) && (scopeRootParent.isAssign())) && ((CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent))) != null))
return (CheckAccessControls.getTypeDeprecationInfo(type)) != null
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
Preconditions.checkState(((scopeCreator) == null))
Preconditions.checkState(((topScope) == null))
Preconditions.checkState(((jsRoot.getParent()) != null))
boolean superClassHasProperty = (superClass != null) && (superClass.getPrototype().hasProperty(propertyName))
boolean declaredOverride = (info != null) && (info.isOverride())
return ((parent == null) || (!(parent.isScript()))) || (!(t.getInput().isExtern()))
Preconditions.checkState(((gramps != null) && (gramps.isVar())))
boolean notProvidedByConstructors = ((constructors) == null) || (!(constructors.contains(className)))
boolean notProvidedByRequires = ((requires) == null) || ((!(requires.contains(className))) && (!(requires.contains(outermostClassName))))
return (((name != null) && ((name.length()) > 1)) && (Character.isUpperCase(name.charAt(0)))) && (!(name.equals(name.toUpperCase())))
return (info != null) && (((info.isConstructor()) && (valueNodeType == (Token.FUNCTION))) || ((info.hasEnumParameterType()) && (valueNodeType == (Token.OBJECTLIT))))
return ((!(inExterns)) && (!(isGetOrSetDefinition()))) && ((isClassOrEnum) || (((((parent) == null) || (parent.canCollapseUnannotatedChildNames())) && (((globalSets) > 0) || ((localSets) > 0))) && ((deleteProps) == 0)))
return ((parent) == null) || (parent.canCollapseUnannotatedChildNames())
return (parent) == null
return (v != null) && (!(v.isLocal()))
return (s.getParent()) == null
Preconditions.checkState((((body.getNext()) == null) && (body.isBlock())))
assignedToUnknownValue = (value != null) && (!(NodeUtil.isLiteralValue(value, true)))
return (getNode(n)) != null
return (((n != null) && ((n.isCall()) || (n.isNew()))) && (n.hasChildren())) && ((qualifiedNameBeginsWithStripType(n.getFirstChild())) || (nameEndsWithFieldNameToStrip(n.getFirstChild())))
return ((propNode != null) && (propNode.isString())) && (isStripName(propNode.getString()))
return (((name != null) && (name.isName())) && (var.getName().equals(name.getString()))) && (NodeUtil.isAssignmentOp(n))
return (((name != null) && (name.isName())) && (var.getName().equals(name.getString()))) && (!(NodeUtil.isVarOrSimpleAssignLhs(name, name.getParent())))
Preconditions.checkState(((compiler) != null))
return (currentInfo.getDescription()) != null
return ((((((((currentInfo.isConstructor()) || (currentInfo.isInterface())) || ((currentInfo.getParameterCount()) > 0)) || (currentInfo.hasReturnType())) || (currentInfo.hasBaseType())) || ((currentInfo.getExtendedInterfacesCount()) > 0)) || ((currentInfo.getLendsName()) != null)) || (currentInfo.hasThisType())) || (hasAnySingletonTypeTags())
Preconditions.checkState((externsAndJs != null))
Preconditions.checkState(((externsRoot == null) || (externsAndJs.hasChild(externsRoot))))
return (info != null) && (info.containsDeclaration())
allowDupe = (info != null) && (info.getSuppressions().contains("duplicate"))
return (getOwnerFunction()) != null
return (input != null) && (input.isReturn())
return !(((ancestors.size()) == 1) && ((ancestors.peek().getNext()) == null))
this.valueHasSideEffects = (valueNode != null) && (NodeUtil.mayHaveSideEffects(valueNode))
return (lookAhead) != null
Preconditions.checkState(((jsonml) != null))
return (input.getSourceFileName()) != null
return (getParameterType(parameter)) != null
return (thisType) != null
return (getBaseType()) != null
return ((info) != null) && ((info.modifies) != null)
return ((info) != null) && ((info.modifies) != null)
return String.format("%s at %s line %s %s", description, (Strings.isNullOrEmpty(sourceName) ? "(unknown source)" : sourceName), (lineNumber < 0 ? String.valueOf(lineNumber) : "(unknown line)"), (lineSource != null ? ":\n\n" + lineSource : "."))
Preconditions.checkState((parent != null), "Cannot find continue target.")
return (ControlFlowAnalysis.isBreakStructure(target, (label != null))) && (ControlFlowAnalysis.matchLabel(target.getParent(), label))
return (variableParent != null) && (variableParent.isParamList())
assert sourceFile != null
return (current) != null
return (cur) != null
Preconditions.checkArgument(((child.parent) == null), "new child has existing parent")
Preconditions.checkArgument(((child.next) == null), "new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null), "first new child has existing parent")
Preconditions.checkArgument(((left.next) == null), "first new child has existing sibling")
Preconditions.checkArgument(((right.parent) == null), "second new child has existing parent")
Preconditions.checkArgument(((right.next) == null), "second new child has existing sibling")
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((left.parent) == null))
Preconditions.checkArgument(((left.next) == null))
Preconditions.checkArgument(((mid.parent) == null))
Preconditions.checkArgument(((mid.next) == null))
Preconditions.checkArgument(((mid2.parent) == null))
Preconditions.checkArgument(((mid2.next) == null))
Preconditions.checkArgument(((right.parent) == null))
Preconditions.checkArgument(((right.next) == null))
Preconditions.checkArgument(((children[(i - 1)].parent) == null))
Preconditions.checkArgument(((children[((children.length) - 1)].parent) == null))
return (first) != null
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.next) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument(((child.parent) == null))
Preconditions.checkArgument((node != null), "The existing child node of the parent should not be null.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkArgument(((newChild.next) == null), "The new child node has siblings.")
Preconditions.checkArgument(((newChild.parent) == null), "The new child node already has a parent.")
Preconditions.checkState(((this.propListHead) == null), "Node has existing properties.")
return ((first) != null) && ((first) == (last))
return ((first) != null) && ((first) != (last))
Preconditions.checkState(((parent) != null))
Preconditions.checkArgument(((prev.next) != null), "no next sibling.")
boolean initialized = (name.getDeclaration()) != null
Preconditions.checkState(((lang) == null))
Preconditions.checkState((((lang) != null) && (!(lang.isEmpty()))))
Preconditions.checkState(((msgBuilder) == null))
Preconditions.checkState(((id != null) && (!(id.isEmpty()))))
Preconditions.checkState(((msgBuilder) != null))
Preconditions.checkState(((msgBuilder) != null))
Preconditions.checkState(((blacklist != null) && (!(blacklist.isEmpty()))), "Not checking use of goog.getCssName because of empty blacklist.")
return new PassConfig.State(((cssNames) == null ? null : Maps.newHashMap(cssNames)), ((exportedNames) == null ? null : Collections.unmodifiableSet(exportedNames)), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return new PassConfig.State(((cssNames) == null ? null : Maps.newHashMap(cssNames)), ((exportedNames) == null ? null : Collections.unmodifiableSet(exportedNames)), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return ObjectType.cast((type == null ? null : type.dereference()))
boolean nonLocalInferredSlot = (isInferred && ((syntacticScope.getParent()) != null)) && (var == (syntacticScope.getParent().getSlot(varName)))
boolean hasLendsName = ((n.getJSDocInfo()) != null) && ((n.getJSDocInfo().getLendsName()) != null)
boolean hasLendsName = ((n.getJSDocInfo()) != null) && ((n.getJSDocInfo().getLendsName()) != null)
return (((v != null) && (v.isLocal())) && (v.isMarkedEscaped())) && ((v.getScope()) == (syntacticScope))
boolean descend = (((parent == null) || (!(parent.isFunction()))) || (n == (parent.getFirstChild()))) || (parent == (scope.getRootNode()))
boolean inferred = keyType == null
Preconditions.checkState(((sourceName) != null))
boolean isFnLiteral = (rValue != null) && (rValue.isFunction())
defineSlot(name, parent, type, (type == null))
Preconditions.checkArgument((inferred || (type != null)))
boolean isValidValue = (initialValue != null) && ((initialValue.isObjectLit()) || (initialValue.isQualifiedName()))
scopeToDeclareIn.declare(prototypeName, n, prototypeSlot.getType(), input, ((superClassCtor == null) || (superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)))))
return (scope != null) && (scope.isGlobal())
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
Preconditions.checkArgument(((qName != null) && (ownerName != null)))
stubDeclarations.add(new TypedScopeCreator.StubDeclaration(n, (((t.getInput()) != null) && (t.getInput().isExtern())), ownerName))
boolean isExtern = ((t.getInput()) != null) && (t.getInput().isExtern())
inferred = !((((info.hasType()) || (info.hasEnumParameterType())) || (((info.isConstant()) && (valueType != null)) && (!(valueType.isUnknownType())))) || (FunctionTypeBuilder.isFunctionTypeDeclaration(info)))
return ObjectType.cast((ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined()))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkArgument((((module == null) || ((this.module) == null)) || ((this.module) == module)))
Preconditions.checkState((fnRecursionName != null))
Preconditions.checkState(((parent.getFirstChild()) == null))
boolean checkModules = isRemovable && (fnModule != null)
compiler.report(JSError.make(NodeUtil.getSourceName(n), n, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, name, ((origVar.input) != null ? origVar.input.getName() : "??")))
Preconditions.checkState(((scope.getParent()) == null))
return (info != null) && (info.getSuppressions().contains("duplicate"))
return (waiting) == null
return ((isDeclaration()) && (!(getParent().isVar()))) || ((nameNode.getFirstChild()) != null)
return (((((parentType == (Token.VAR)) && ((nameNode.getFirstChild()) != null)) || (parentType == (Token.INC))) || (parentType == (Token.DEC))) || ((NodeUtil.isAssignmentOp(parent)) && ((parent.getFirstChild()) == (nameNode)))) || (ReferenceCollectingCallback.Reference.isLhsOfForInExpression(nameNode))
return (getParent()) == null
return (gramps == null) || (!(gramps.isScript()))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
Preconditions.checkArgument(((source == null) || ((Token.FUNCTION) == (source.getType()))))
Preconditions.checkArgument((name != null))
boolean replacedPrototype = oldPrototype != null
this.prototypeSlot = new ObjectType.Property("prototype", prototype, true, (propertyNode == null ? source : propertyNode))
boolean treatThisTypesAsCovariant = ((((this.isConstructor()) || (other.isConstructor())) || (((other.typeOfThis.getConstructor()) != null) && (other.typeOfThis.getConstructor().isInterface()))) || (other.typeOfThis.isSubtype(this.typeOfThis))) || (this.typeOfThis.isSubtype(other.typeOfThis))
return ((prototypeSlot) != null) || (super.hasCachedValues())
boolean preferLineBreaks = (type == (Token.SCRIPT)) || ((((type == (Token.BLOCK)) && (!preserveBlock)) && ((n.getParent()) != null)) && (n.getParent().isScript()))
return (n == null) || ((!(NodeUtil.canBeSideEffected(n))) && (!(NodeUtil.mayHaveSideEffects(n))))
boolean constructorHasArgs = (constructorNameNode.getNext()) != null
Preconditions.checkState(((value.getParent()) == null))
this(sourceName, node, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
this(sourceName, node, (node != null ? node.getLineno() : -1), (node != null ? node.getCharno() : -1), type, null, arguments)
return ((((((((type.key) + ". ") + (description)) + " at ") + (((sourceName) != null) && ((sourceName.length()) > 0) ? sourceName : "(unknown source)")) + " line ") + ((lineNumber) != (-1) ? String.valueOf(lineNumber) : "(unknown line)")) + " : ") + ((charno) != (-1) ? String.valueOf(charno) : "(unknown column)")
return classes != null
boolean aliasable = (!(unaliasableGlobals.contains(dest.getString()))) && ((docInfo == null) || (!(docInfo.isNoAlias())))
Preconditions.checkState(((this.newName) == null))
boolean local = ((var != null) && (var.isLocal())) && ((!(var.scope.getParent().isGlobal())) || (!(var.isBleedingFunction())))
boolean isBleedingIntoScope = ((s.getParent()) != null) && (localBleedingFunctions.contains(v))
return (name != null) && (name.endsWith(CheckMissingGetCssName.GET_UNIQUE_ID_FUNCTION))
return (qname != null) && (isIdName(qname))
return (((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
return (((((objType == null) || (invalidatingTypes.contains(objType))) || (!(objType.hasReferenceName()))) || (objType.isUnknownType())) || (objType.isEnumType())) || ((objType.autoboxesTo()) != null)
Preconditions.checkState((meaning != null))
String projectScopedMeaning = ((projectId) != null ? (projectId) + ": " : "") + meaning
return (fn) != null
Preconditions.checkState(((this.fn) == null))
return ((references) != null) && (!(references.isEmpty()))
Preconditions.checkArgument((compiler != null))
Preconditions.checkArgument((safeNameIdSupplier != null))
Preconditions.checkArgument((changed != null))
Preconditions.checkState((fn != null))
return (containingFunction(node)) == null
Preconditions.checkArgument(((typeofNode.getFirstChild()) != null))
return (parent != null) && (NodeUtil.isGet(parent))
Preconditions.checkArgument(((inputsSupplier == null) ^ (modulesSupplier == null)))
Preconditions.checkArgument(((inputsSupplier == null) ^ (modulesSupplier == null)))
Preconditions.checkState((specs != null))
Preconditions.checkState((jsFiles != null))
Preconditions.checkState((specs != null))
return ((options.sourceMapOutputPath) != null) && (options.sourceMapOutputPath.contains("%outname%"))
return ((!(config.module.isEmpty())) && (output != null)) && (output.contains("%outname%"))
Preconditions.checkArgument(((declaration.getJSType()) != null))
return ((input) == null) || (input.isExtern())
return ((nameNode) != null) && (NodeUtil.isConstantName(nameNode))
return ((((var.getParentNode()) != null) && ((var.getType()) == null)) && (var.getParentNode().isVar())) && (!(var.isExtern()))
return ((((var.getParentNode()) != null) && ((var.getType()) == null)) && (var.getParentNode().isVar())) && (!(var.isExtern()))
Preconditions.checkState(((name != null) && ((name.length()) > 0)))
Preconditions.checkState(((vars.get(name)) == null))
Scope.Var var = new Scope.Var(inferred, name, nameNode, type, this, vars.size(), input, ((info != null) && (info.isDefine())), info)
return (parent) == null
Preconditions.checkState((expressionRoot != null))
Preconditions.checkArgument(((lastLink.nextLink) == null))
boolean allowWith = (info != null) && (info.getSuppressions().contains("with"))
Preconditions.checkArgument((unsafe != null))
return ((!(skipRenaming)) && ((types) != null)) && ((types.allEquivalenceClasses().size()) > 1)
compiler.report(JSError.make(t.getSourceName(), n, propertiesToErrorFor.get(name), DisambiguateProperties.Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString(), suggestion))
compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), DisambiguateProperties.Warnings.INVALIDATION, name, (type == null ? "null" : type.toString()), n.toString(), ""))
return (objType != null) && (!(objType.hasReferenceName()))
return (type.isEnumType()) || ((type.autoboxesTo()) != null)
return (((type == null) || (type.isAll())) || (type.isFunction())) || ((type.isInstance()) && (invalidatingTypes.contains(type.toInstance().instanceType)))
return ((var != null) && ((var.getScope()) == s)) && (!(blacklistedVars.contains(var)))
return (displayName != null) && (!(displayName.isEmpty()))
return (toMaybeUnionType()) != null
return (toMaybeFunctionType()) != null
return (toMaybeEnumElementType()) != null
return (toMaybeEnumType()) != null
return (toMaybeRecordType()) != null
assert record != null
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isOptionalArg())
return ((info != null) && (info.hasParameterType(paramName))) && (info.getParameterType(paramName).isVarArgs())
return (isUnknownType()) || ((getSlot(propertyName)) != null)
return (properties.get(propertyName)) != null
return (properties.remove(name)) != null
return ((className) != null) || ((ownerFunction) != null)
return ((className) != null) || ((ownerFunction) != null)
Preconditions.checkState((((ownerFunction) == null) || (type == null)))
Preconditions.checkState((((ownerFunction) == null) || (type == null)))
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean aIsNull = (slotA == null) || ((slotA.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
boolean bIsNull = (slotB == null) || ((slotB.getType()) == null)
boolean shouldBeConstant = ((info != null) && (info.isConstant())) || (NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent))
Preconditions.checkState((externsAndJs != null))
return (var != null) && (var.isConst())
Preconditions.checkState((result != null))
return (registerFunction) != null
return (registerCall) != null
Preconditions.checkState((nameNode != null))
Preconditions.checkState((value != null))
Preconditions.checkState((value != null))
return (NodeUtil.isFunctionDeclaration(initialization.getParent())) || ((initialization.getNode().getFirstChild()) != null)
CheckNotNull  in 4330ms
Exception in thread "main" spoon.SpoonException: Cannot create MethodTypingContext for method declared in different ClassTypingContext
	at spoon.support.visitor.MethodTypingContext.setMethod(MethodTypingContext.java:71)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:616)
	at spoon.support.visitor.ClassTypingContext.isSameSignature(ClassTypingContext.java:312)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:959)
	at spoon.support.reflect.declaration.CtTypeImpl$2.accept(CtTypeImpl.java:955)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:78)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction$1.accept(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.chain.CtQueryImpl$OutputFunctionWrapper._accept(CtQueryImpl.java:444)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.sendResult(SuperInheritanceHierarchyFunction.java:360)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperInterfaces(SuperInheritanceHierarchyFunction.java:308)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:266)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.visitSuperClasses(SuperInheritanceHierarchyFunction.java:283)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:248)
	at spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.apply(SuperInheritanceHierarchyFunction.java:51)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:73)
	at spoon.reflect.visitor.filter.AllTypeMembersFunction.apply(AllTypeMembersFunction.java:36)
	at spoon.reflect.visitor.chain.CtQueryImpl$LazyFunctionWrapper._accept(CtQueryImpl.java:478)
	at spoon.reflect.visitor.chain.CtQueryImpl$AbstractStep.accept(CtQueryImpl.java:308)
	at spoon.reflect.visitor.chain.CtQueryImpl.forEach(CtQueryImpl.java:94)
	at spoon.support.reflect.declaration.CtTypeImpl.getAllMethods(CtTypeImpl.java:955)
	at spoon.reflect.visitor.ImportScannerImpl.isInCollisionWithLocalMethod(ImportScannerImpl.java:408)
	at spoon.reflect.visitor.ImportScannerImpl.addMethodImport(ImportScannerImpl.java:431)
	at spoon.reflect.visitor.ImportScannerImpl.visitCtExecutableReference(ImportScannerImpl.java:106)
	at spoon.support.reflect.reference.CtExecutableReferenceImpl.accept(CtExecutableReferenceImpl.java:84)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:495)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.ImportScannerImpl.scan(ImportScannerImpl.java:135)
	at spoon.reflect.visitor.ImportScannerImpl.computeImports(ImportScannerImpl.java:204)
	at spoon.reflect.visitor.DefaultJavaPrettyPrinter.computeImports(DefaultJavaPrettyPrinter.java:293)
	at spoon.support.reflect.declaration.CtElementImpl.toString(CtElementImpl.java:252)
	at java.lang.String.valueOf(String.java:2994)
	at java.io.PrintStream.println(PrintStream.java:821)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:118)
	at fr.inria.spirals.npefix.transformer.processors.CheckNotNull.process(CheckNotNull.java:29)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:81)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtConditional(CtScanner.java:345)
	at spoon.support.reflect.code.CtConditionalImpl.accept(CtConditionalImpl.java:43)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:494)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtInvocation(CtScanner.java:496)
	at spoon.support.reflect.code.CtInvocationImpl.accept(CtInvocationImpl.java:56)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtBlock(CtScanner.java:291)
	at spoon.support.reflect.code.CtBlockImpl.accept(CtBlockImpl.java:48)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.visitCtMethod(CtScanner.java:549)
	at spoon.support.reflect.declaration.CtMethodImpl.accept(CtMethodImpl.java:70)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:157)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:141)
	at spoon.reflect.visitor.CtScanner.visitCtClass(CtScanner.java:327)
	at spoon.support.reflect.declaration.CtClassImpl.accept(CtClassImpl.java:68)
	at spoon.reflect.visitor.CtScanner.scan(CtScanner.java:165)
	at spoon.support.visitor.ProcessingVisitor.scan(ProcessingVisitor.java:77)
	at spoon.support.QueueProcessingManager.process(QueueProcessingManager.java:119)
	at fr.inria.spirals.npefix.main.all.Launcher.instrument(Launcher.java:105)
	at fr.inria.spirals.npefix.main.run.Main.run(Main.java:61)
	at fr.inria.spirals.npefix.main.run.Main.main(Main.java:48)
Command exited with non-zero status 1
62.56user 1.50system 0:19.04elapsed 336%CPU (0avgtext+0avgdata 1660492maxresident)k
31744inputs+144outputs (14major+431647minor)pagefaults 0swaps


Node: suno-32.sophia.grid5000.fr



Date: Sat May  4 21:06:54 EDT 2019

