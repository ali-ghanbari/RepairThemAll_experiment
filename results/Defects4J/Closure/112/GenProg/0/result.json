{
  "repair_end": "2018-12-02 12:28:50.739578", 
  "repair_begin": "2018-12-02 11:54:48.751194", 
  "patches": [
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_358/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:20.333404513 -0500\n@@ -1062,83 +1062,20 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_358/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:07:20.337404525 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_173/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:29.292908930 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1103,8 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tmap.put(template, join);\n       }\n     }\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_545/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:55.349875073 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1829/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:44.169310436 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1145,7 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n+      int start = 0;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n@@ -1356,7 +1333,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_292/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:17.561229555 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_77/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:04.396672376 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1078,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_143/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:01.664831470 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:30.977077210 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:27:30.977077210 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1727/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:30.981077224 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1751/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:49.269136038 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1751/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:27:49.269136038 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1621/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:10.024817044 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1621/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:26:10.024817044 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1621/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:26:10.028817057 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1215/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:28.787694062 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1215/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:20:28.787694062 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1215/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:20:28.791694074 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1215/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:20:28.791694074 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return FALSE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_697/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:15.326268480 -0500\n@@ -1039,10 +1039,7 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_257/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:05:48.025144744 -0500\n@@ -1062,83 +1062,20 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1414/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:18.220261739 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1333,7 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n+        final String paramName = \"jscomp_throw_param\";\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_729/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:44.906348087 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1353,7 +1330,8 @@\n       JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n       if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n           && propertyType.hasAnyTemplateTypes()) {\n-        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        StringBuilder builder = new StringBuilder();\n+\t\tTemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n         propertyType = propertyType.visit(replacer);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1356, 
          "faulty": "TemplateTypeMap typeMap=restrictedObjType.getTemplateTypeMap();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1124/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:12.795461973 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1124/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:19:12.795461973 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1771/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:03.405181247 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1332,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_769/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:13:18.662437787 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1072,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1353,7 +1278,8 @@\n       JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n       if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n           && propertyType.hasAnyTemplateTypes()) {\n-        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        StringBuilder builder = new StringBuilder();\n+\t\tTemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n         propertyType = propertyType.visit(replacer);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1356, 
          "faulty": "TemplateTypeMap typeMap=restrictedObjType.getTemplateTypeMap();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_681/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:01.186230061 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_679/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:00.186227336 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_679/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:12:00.190227345 -0500\n@@ -685,8 +685,7 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n+        final String paramName = \"jscomp_throw_param\";\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_181/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:36.328930661 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_452/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:41.661652690 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1078,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_452/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:08:41.661652690 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_261/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:05:51.109153683 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1148,7 +1133,8 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        int start = 0;\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1826/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:42.125303998 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1826/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:42.125303998 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1367/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:40.692139184 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1046,10 +1047,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1367/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:22:40.696139197 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1421/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:23.260278065 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1573/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:29.208685203 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1573/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:25:29.208685203 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1573/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:25:29.212685216 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1294/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:33.767901381 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1144,14 +1145,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1294/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:21:33.771901396 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1033/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:17:53.623205543 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1533/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:53.052566728 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1533/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:24:53.052566728 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_137/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:56.616817669 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1098,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_764/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:13:14.594427037 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_200/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:52.564980276 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1353,7 +1305,8 @@\n       JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n       if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n           && propertyType.hasAnyTemplateTypes()) {\n-        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        int start = 0;\n+\t\tTemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n         propertyType = propertyType.visit(replacer);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1356, 
          "faulty": "TemplateTypeMap typeMap=restrictedObjType.getTemplateTypeMap();", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1746/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:46.133125979 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1746/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:46.137125991 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_466/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:54.185691441 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_884/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:12.142732201 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_884/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:15:12.146732212 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1337/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:12.520043784 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1130,28 +1131,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1337/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:22:12.520043784 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_520/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:34.013812004 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_520/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:09:34.013812004 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1247/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:55.475773008 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1465/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:56.676385550 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1393/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:02.036209105 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1393/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:23:02.040209118 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "case 3:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1095/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:48.215384173 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_360/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:21.357407314 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1078,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_360/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:07:21.357407314 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_689/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:08.346249546 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1193/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:10.327638734 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1193/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:20:10.331638746 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1076/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:32.839334718 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1076/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:18:32.843334730 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1440/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:36.484320757 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1440/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:23:36.488320770 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_366/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:26.449421222 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_374/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:32.645438094 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1078,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_718/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:34.858321157 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1093/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:47.223381001 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1093/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:18:47.227381013 -0500\n@@ -350,7 +350,8 @@\n       ImmutableList<String> typeParameters = info.getTemplateTypeNames();\n       if (!typeParameters.isEmpty()) {\n         if (isConstructor || isInterface) {\n-          ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+          int index = -1;\n+\t\tImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n           for (String typeParameter : typeParameters) {\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 353, 
          "faulty": "ImmutableList.Builder<TemplateType> builder=ImmutableList.builder();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_916/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:44.494814541 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_916/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:15:44.498814552 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_524/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:37.089821159 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_935/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:16:15.870893863 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_55/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:02:43.744613503 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1062,54 +1061,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1221/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:33.863709169 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1221/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:20:33.863709169 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_190/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:43.572952887 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1711/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:18.877038088 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1711/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:27:18.881038101 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1711/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:18.881038101 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_745/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:57.014380394 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1353,7 +1334,8 @@\n       JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n       if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n           && propertyType.hasAnyTemplateTypes()) {\n-        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tTemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n         propertyType = propertyType.visit(replacer);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1356, 
          "faulty": "TemplateTypeMap typeMap=restrictedObjType.getTemplateTypeMap();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1775/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:05.565188135 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1046,10 +1047,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1775/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:05.569188148 -0500\n@@ -685,8 +685,7 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n+        final String paramName = \"jscomp_throw_param\";\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1775/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:05.569188148 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1645/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:29.760880112 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1645/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:26:29.760880112 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_961/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:16:47.678976769 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_961/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:16:47.682976783 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_457/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:45.721665299 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1078,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1236/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:46.275745926 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1236/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:20:46.279745937 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1236/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:20:46.279745937 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1286/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:27.863879122 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1286/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:27.867879137 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_826/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:14:12.302578171 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_312/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:35.557280403 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1148,7 +1087,8 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        int start = 0;\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1319/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:55.287981228 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1144,14 +1145,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1161,7 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n+      StringBuilder builder = new StringBuilder();\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1319/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:21:55.287981228 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1497/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:22.420467493 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1713/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:19.877041328 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_739/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:52.998369694 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1354,7 +1346,8 @@\n       if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n           && propertyType.hasAnyTemplateTypes()) {\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n-        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n+        int start = 0;\n+\t\tTemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n         propertyType = propertyType.visit(replacer);\n       }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1357, 
          "faulty": "TemplateTypeMapReplacer replacer=new TemplateTypeMapReplacer(registry,typeMap);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1696/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:08.601004728 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1696/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:27:08.601004728 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1696/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:08.601004728 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_492/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:12.785748229 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1434/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:32.432307698 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1130,28 +1131,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1434/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:23:32.436307710 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1709/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:17.785034549 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1709/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:17.789034562 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_108/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:30.756746318 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1148,7 +1102,8 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        int start = 0;\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_298/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:22.569243766 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1084,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n@@ -1148,7 +1094,8 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        int start = 0;\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1412/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:17.216258484 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1412/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:23:17.220258496 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1578/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:33.400698834 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1578/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:25:33.404698847 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1578/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:25:33.404698847 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_922/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:54.558840037 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_922/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:15:54.562840048 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_792/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:13:40.026493994 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_792/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:13:40.030494004 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1688/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:01.576981854 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1688/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:27:01.580981866 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1253/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:00.699788326 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1253/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:21:00.703788338 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1253/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:21:00.703788338 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "return FALSE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_121/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:43.348781201 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_121/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:03:43.352781212 -0500\n@@ -355,7 +355,8 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n+          int index = -1;\n+\t\ttypeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_128/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:49.528798223 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1031/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:17:52.623202187 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1144,14 +1145,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1031/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:17:52.627202202 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1031/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:17:52.627202202 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1386/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:58.036196045 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1130,28 +1131,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1798/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:21.653239290 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1798/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:21.657239303 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1798/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:21.657239303 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_799/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:13:46.210510189 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_799/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:13:46.214510199 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "case 2:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1605/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:54.944768560 -0500\n@@ -964,7 +964,8 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n+      int index = -1;\n+\tfnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1038,7 +1039,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1126,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1605/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:25:54.948768573 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1791/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:17.589226393 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1791/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:28:17.593226406 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1791/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:17.593226406 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1755/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:52.261145624 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1755/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:52.261145624 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1817/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:35.037281642 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1334,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1817/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:35.037281642 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_320/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:42.605300159 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1079,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1419/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:22.264274841 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_558/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:10:06.397907354 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1078,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_607/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:10:53.766043114 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1335/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:11.500040114 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1335/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:22:11.504040128 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1335/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:22:11.504040128 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_94/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:18.776712872 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1016/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:17:39.407157537 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1148,8 +1133,6 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_646/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:11:31.698149104 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1209/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:23.499678276 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1209/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:20:23.499678276 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1432/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:31.324304123 -0500\n@@ -1143,15 +1143,6 @@\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1800/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:22.653242461 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1800/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:22.657242473 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_866/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:14:50.606677044 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1164/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:47.067568104 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1597/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:48.656748266 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1046,10 +1047,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Replace", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_498/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:16.973760896 -0500\n@@ -1038,11 +1038,9 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1062,54 +1060,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1076,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1083,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_498/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:09:16.977760908 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        int start = 0;\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1202/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:18.355662872 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1144,14 +1145,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1202/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:20:18.359662884 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_135/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:55.620814942 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1062,54 +1061,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1077,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_474/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:59.321707210 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_474/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:08:59.325707223 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_474/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:08:59.325707223 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "case 2:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1764/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:59.325168221 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1764/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:59.325168221 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1463/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:55.696382415 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1185/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:04.267620435 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1185/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:20:04.271620447 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1185/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:20:04.271620447 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1185/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:20:04.271620447 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return FALSE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1307/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:43.967939475 -0500\n@@ -1058,58 +1058,7 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    StringBuilder builder = new StringBuilder();\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1073,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1206/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:21.487672257 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1206/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:20:21.487672257 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1725/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:29.957073919 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1725/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:27:29.961073932 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1725/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:29.961073932 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1346/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:20.772073332 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1346/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:22:20.772073332 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_547/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:56.349878006 -0500\n@@ -1039,10 +1039,7 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1128,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1135/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:22.967493744 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1135/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:19:22.971493758 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1135/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:19:22.971493758 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1135/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:19:22.971493758 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return FALSE;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_648/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:11:32.682151825 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1369/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:41.792142802 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1369/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:22:41.796142815 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1369/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:22:41.796142815 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1780/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:09.565200880 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1780/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:09.569200892 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_409/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:03.953533291 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1682/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:57.548968709 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1682/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:26:57.548968709 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1682/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:26:57.552968722 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-02 05:54:28.043329273 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1682/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-02 06:26:57.552968722 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1655/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:37.124903537 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1333,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1065/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:23.615304740 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1065/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:18:23.615304740 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1528/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:50.000556649 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_439/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:30.541617918 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_742/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:55.034375121 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_742/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:12:55.034375121 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "case 2:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1635/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:22.668857499 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1635/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:26:22.668857499 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1635/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:26:22.668857499 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1044/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:03.967240066 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1425/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:26.264287781 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1137/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:23.967496856 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_938/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:16:17.850898854 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1348,7 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n+        int start = 0;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1795/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:19.613232818 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1046,10 +1047,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1795/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:19.617232830 -0500\n@@ -685,8 +685,7 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n+        final String paramName = \"jscomp_throw_param\";\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1795/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:19.617232830 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1562/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:18.972651829 -0500\n@@ -964,7 +964,8 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n+      int index = -1;\n+\tfnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1046/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:04.971243398 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1046/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:18:04.971243398 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1173/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:55.047592456 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1173/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:19:55.047592456 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1807/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:27.837258882 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1334,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1807/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:27.841258894 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1495/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:21.380464197 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1495/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:24:21.380464197 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_610/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:10:55.830048939 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1749/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:48.265132818 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1749/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:27:48.265132818 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1749/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:48.265132818 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_670/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:11:52.018205016 -0500\n@@ -1062,61 +1062,16 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n+    int index = -1;\n+\tmaybeResolveTemplateTypeFromNodes(\n         declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n@@ -1124,34 +1079,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_226/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:05:18.389057771 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1079,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_517/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:31.741805228 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1103,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1731/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:34.069087181 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1731/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:27:34.073087194 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_469/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:56.297697934 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1669/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:47.364936014 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1669/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:26:47.364936014 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1669/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:26:47.368936026 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1257/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:03.719797162 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,7 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n+        int index = -1;\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1257/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:21:03.719797162 -0500\n@@ -355,7 +355,7 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n+          return this;\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1257/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:03.723797174 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1388/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:59.032199299 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1388/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:22:59.036199312 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_565/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:10:12.537925187 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1088,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_281/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:08.389203405 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_281/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:06:08.393203417 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1116/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:06.727442905 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1116/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:19:06.727442905 -0500\n@@ -350,7 +350,8 @@\n       ImmutableList<String> typeParameters = info.getTemplateTypeNames();\n       if (!typeParameters.isEmpty()) {\n         if (isConstructor || isInterface) {\n-          ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+          int index = -1;\n+\t\tImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n           for (String typeParameter : typeParameters) {\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1116/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:19:06.731442917 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 353, 
          "faulty": "ImmutableList.Builder<TemplateType> builder=ImmutableList.builder();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_658/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:11:41.802176977 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1079,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1809/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:28.829262020 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_250/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:05:42.017127271 -0500\n@@ -1058,58 +1058,13 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n+    final String paramName = \"jscomp_throw_param\";\n+\tif (paramType.isTemplateType()) {\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1148,7 +1103,8 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        int start = 0;\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1661/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:42.156919510 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1109/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:00.523423316 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1109/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:19:00.523423316 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1757/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:53.265148839 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1757/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:53.269148853 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_733/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:47.970356277 -0500\n@@ -1126,10 +1126,7 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n+      StringBuilder builder = new StringBuilder();\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_496/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:15.865757549 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1078,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_513/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:28.521795606 -0500\n@@ -1038,11 +1038,9 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1062,54 +1060,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1076,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_80/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:06.492678303 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_80/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:03:06.496678314 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1176/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:57.123598770 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1176/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:19:57.123598770 -0500\n@@ -685,8 +685,7 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n+        final String paramName = \"jscomp_throw_param\";\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1081/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:36.823347592 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1145,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1081/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:18:36.827347605 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_303/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:27.021256359 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,21 +1125,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_713/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:12:30.778310190 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_380/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:37.697451810 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_380/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:07:37.701451822 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        int index = -1;\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_183/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:37.320933713 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1508/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:32.756500191 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1590/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:42.636728793 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1590/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:25:42.640728806 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1011/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:17:35.251143373 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1011/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:17:35.251143373 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_956/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:16:44.522965893 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1442/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:37.484323977 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1356/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:30.116104319 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1145,7 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n+      StringBuilder builder = new StringBuilder();\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1356/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:22:30.116104319 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1356/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:22:30.120104333 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1542/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:00.596591584 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1457/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:50.736366537 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1457/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:23:50.736366537 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1406/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:13.152245292 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1406/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:23:13.156245304 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1282/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:24.895867872 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1129,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1282/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:24.895867872 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1717/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:22.925051195 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1717/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:22.925051195 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1226/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:38.059721625 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_433/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:25.513602079 -0500\n@@ -1039,10 +1039,7 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1062,54 +1059,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1815/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:34.033278472 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1815/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:34.037278484 -0500\n@@ -685,8 +685,7 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n+        final String paramName = \"jscomp_throw_param\";\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1653/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:36.120900347 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_388/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:44.817471087 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1079,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_388/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:07:44.817471087 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 2:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_511/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:27.517792601 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1822/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:39.081294403 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1822/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:28:39.081294403 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1822/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:39.085294416 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_757/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:13:08.374410569 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_542/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:53.309869085 -0500\n@@ -1038,11 +1038,9 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1122,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1129,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_479/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:02.297716317 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_479/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:09:02.297716317 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1679/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:55.464961900 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1628/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:16.304837159 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1628/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:26:16.308837172 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1628/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:26:16.308837172 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1802/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:23.677245707 -0500\n@@ -1116,42 +1116,17 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n+    int start = 0;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1802/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:23.681245719 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1429/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:29.332297693 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1429/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:23:29.332297693 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1531/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:52.044563400 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1144,14 +1145,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1118/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:07.723446039 -0500\n@@ -1116,42 +1116,18 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n+    final String paramName = \"jscomp_throw_param\";\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1118/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:19:07.727446053 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_989/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:17:15.103073853 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1145,8 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n+      final String paramName = \"jscomp_throw_param\";\n+\tmadeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1485/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:13.248438382 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1485/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:24:13.248438382 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1789/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:16.565223140 -0500\n@@ -1059,7 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n+      int start = 0;\n+\t// @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n@@ -1124,34 +1125,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1789/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:28:16.569223154 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1789/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:16.569223154 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1262/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:06.803806172 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1262/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:06.803806172 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1154/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:39.059543535 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1072,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1154/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:19:39.063543547 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_87/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:12.752695954 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_87/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:03:12.752695954 -0500\n@@ -355,7 +355,7 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n+          int index = -1;\n         }\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_471/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:57.289700980 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_419/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:13.453563778 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,21 +1125,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_419/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:08:13.453563778 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1436/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:33.420310883 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1160,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n@@ -1356,7 +1347,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_158/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:16.032870535 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_158/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:04:16.032870535 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1187/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:05.271623471 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1296/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:34.771905151 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1296/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:21:34.771905151 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1296/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:34.775905166 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1162/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:46.071565056 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1162/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:19:46.075565068 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1162/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:19:46.075565068 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_403/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:58.961517155 -0500\n@@ -1038,11 +1038,9 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1062,54 +1060,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1076,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:29.819324929 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1072/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:18:29.819324929 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_926/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:57.646847852 -0500\n@@ -1126,7 +1126,8 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n+      int start = 0;\n+\tmaybeResolveTemplatedType(\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n@@ -1144,14 +1145,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_926/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:15:57.650847860 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1239/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:48.311751930 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1239/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:20:48.315751943 -0500\n@@ -685,8 +685,7 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n+        final String paramName = \"jscomp_throw_param\";\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1773/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:04.453184589 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1353,7 +1331,8 @@\n       JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n       if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n           && propertyType.hasAnyTemplateTypes()) {\n-        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        int index = -1;\n+\t\tTemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n         propertyType = propertyType.visit(replacer);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1773/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:28:04.453184589 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1356, 
          "faulty": "TemplateTypeMap typeMap=restrictedObjType.getTemplateTypeMap();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1481/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:10.044428191 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1046,10 +1047,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1698/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:09.681008240 -0500\n@@ -964,7 +964,8 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n+      int index = -1;\n+\tfnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1698/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:09.685008254 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1084/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:39.015354659 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1084/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:18:39.019354670 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1084/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:18:39.019354670 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1292/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:32.767897622 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1292/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:32.767897622 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1390/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:00.036202578 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1390/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:23:00.036202578 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1793/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:18.605229619 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1793/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:18.609229631 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1549/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:06.628611406 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_71/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:02:59.344658053 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_170/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:04:27.176902368 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1143,12 +1097,14 @@\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n+    final String paramName = \"jscomp_throw_param\";\n+\tJSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        int start = 0;\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_443/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:33.549627359 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1148,7 +1133,8 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1259/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:04.723800096 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1259/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:04.727800109 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1639/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:25.720867237 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1639/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:26:25.724867251 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1639/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:26:25.724867251 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_287/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:13.521218056 -0500\n@@ -1062,62 +1062,15 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n+    StringBuilder builder = new StringBuilder();\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1148,7 +1101,8 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n+        int start = 0;\n+\t\tJSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n       }\n     }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_476/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:00.317710261 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1333,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "int type=n.getType();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1303/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:40.895928051 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1474/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:03.988408898 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1474/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:24:03.988408898 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        int start = 0;\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1474/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:24:03.988408898 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_101/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:03:24.768729634 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1310,7 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n+        int index = -1;\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1835/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:49.193326241 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1005/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:17:30.191126051 -0500\n@@ -1116,42 +1116,17 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1005/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:17:30.191126051 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_368/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:07:27.473424014 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1062,54 +1058,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1074,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_959/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:16:46.666973128 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_959/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:16:46.670973143 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_898/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:23.278760612 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_45/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:02:34.188585960 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_45/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:02:34.192585971 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1099/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:18:51.231393799 -0500\n@@ -1116,42 +1116,17 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1099/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:18:51.235393813 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1232/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:43.139736663 -0500\n@@ -1116,42 +1116,17 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1328/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:22:05.472018340 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1328/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:22:05.472018340 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1328/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:22:05.476018356 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_889/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:16.258742710 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:01:35.752418583 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1583/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:37.476712068 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1583/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:25:37.476712068 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_893/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:19.294750455 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_849/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:14:34.474635529 -0500\n@@ -1124,34 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n+    int start = 0;\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1767/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:01.385174799 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1767/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:01.385174799 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_875/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:14:59.002698582 -0500\n@@ -1039,10 +1039,7 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      int index = -1;\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_508/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:25.385786211 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_508/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:09:25.389786223 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_508/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:09:25.389786223 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 3:"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 3:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1143/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:19:28.967512376 -0500\n@@ -1062,54 +1062,43 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else {\n+\t\tfinal String paramName = \"jscomp_throw_param\";\n+\t\tif (paramType.isUnionType()) {\n+\t\t\tUnionType unionType = paramType.toMaybeUnionType();\n+\t\t\tfor (JSType alernative : unionType.getAlternates()) {\n+\t\t\t\tmaybeResolveTemplatedType(alernative, argType, resolvedTypes);\n+\t\t\t}\n+\t\t} else if (paramType.isFunctionType()) {\n+\t\t\tFunctionType paramFunctionType = paramType.toMaybeFunctionType();\n+\t\t\tFunctionType argFunctionType = argType\n+\t\t\t\t\t.restrictByNotNullOrUndefined().collapseUnion()\n+\t\t\t\t\t.toMaybeFunctionType();\n+\t\t\tif (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n+\t\t\t\tmaybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),\n+\t\t\t\t\t\targFunctionType.getTypeOfThis(), resolvedTypes);\n+\t\t\t\tmaybeResolveTemplatedType(paramFunctionType.getReturnType(),\n+\t\t\t\t\t\targFunctionType.getReturnType(), resolvedTypes);\n+\t\t\t\tmaybeResolveTemplateTypeFromNodes(\n+\t\t\t\t\t\tparamFunctionType.getParameters(),\n+\t\t\t\t\t\targFunctionType.getParameters(), resolvedTypes);\n+\t\t\t}\n+\t\t} else if (paramType.isTemplatizedType()) {\n+\t\t\tObjectType referencedParamType = paramType.toMaybeTemplatizedType()\n+\t\t\t\t\t.getReferencedType();\n+\t\t\tJSType argObjectType = argType.restrictByNotNullOrUndefined()\n+\t\t\t\t\t.collapseUnion();\n+\t\t\tif (argObjectType.isSubtype(referencedParamType)) {\n+\t\t\t\tTemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n+\t\t\t\tTemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n+\t\t\t\tfor (TemplateType key : paramTypeMap.getTemplateKeys()) {\n+\t\t\t\t\tmaybeResolveTemplatedType(\n+\t\t\t\t\t\t\tparamTypeMap.getTemplateType(key),\n+\t\t\t\t\t\t\targTypeMap.getTemplateType(key), resolvedTypes);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1113,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1148,8 +1122,6 @@\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1667/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:46.236932441 -0500\n@@ -964,7 +964,8 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n+      int index = -1;\n+\tfnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1667/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:26:46.240932455 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1181/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:20:01.139610961 -0500\n@@ -1116,42 +1116,18 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n+    final String paramName = \"jscomp_throw_param\";\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1181/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:20:01.139610961 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_279/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:07.369200487 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      final String paramName = \"jscomp_throw_param\";\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1099,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_660/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:11:42.798179716 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1537/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:56.252577280 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1401/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:08.968231689 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1401/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:23:08.968231689 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1275/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:21:18.855844849 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1275/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:21:18.859844864 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1469/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:59.804395545 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1469/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:23:59.808395558 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1702/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:12.753018222 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1702/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:12.757018235 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1488/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:15.308444928 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,7 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n+      int index = -1;\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,34 +1118,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1488/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:24:15.308444928 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1586/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:39.644719099 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1586/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:25:39.648719113 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1451/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:45.736350504 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1353,7 +1345,8 @@\n       JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n       if (!restrictedObjType.getTemplateTypeMap().isEmpty()\n           && propertyType.hasAnyTemplateTypes()) {\n-        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tTemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n         propertyType = propertyType.visit(replacer);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1356, 
          "faulty": "TemplateTypeMap typeMap=restrictedObjType.getTemplateTypeMap();", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_790/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:13:38.922491099 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_506/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:24.389783222 -0500\n@@ -1038,11 +1038,9 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1122,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1129,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1769/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:02.409178068 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1769/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:28:02.413178080 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Replace", 
          "seed": "formatConclusion();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1021/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:17:43.387171044 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1021/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:17:43.387171044 -0500\n@@ -350,7 +350,8 @@\n       ImmutableList<String> typeParameters = info.getTemplateTypeNames();\n       if (!typeParameters.isEmpty()) {\n         if (isConstructor || isInterface) {\n-          ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+          int index = -1;\n+\t\tImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n           for (String typeParameter : typeParameters) {\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 353, 
          "faulty": "ImmutableList.Builder<TemplateType> builder=ImmutableList.builder();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1650/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:33.708892679 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_526/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:38.097824154 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_526/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:09:38.097824154 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1739/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:41.097109803 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1739/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:41.101109816 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1409/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:23:15.172251851 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1145,7 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n+      StringBuilder builder = new StringBuilder();\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1409/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-02 06:23:15.172251851 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "case 0:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "InsertBefore", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_591/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:10:38.425999589 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,21 +1125,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1602/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:25:52.736761439 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1602/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:25:52.736761439 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1677/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:54.480958684 -0500\n@@ -964,7 +964,8 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n+      int index = -1;\n+\tfnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:49.012553385 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:24:49.012553385 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1526/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:24:49.012553385 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "case 0:"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_489/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:10.593741582 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_913/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:15:42.502809487 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_913/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:15:42.502809487 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1744/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:45.129122757 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 05:54:27.991329275 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1744/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-02 06:27:45.129122757 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1744/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:45.129122757 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1707/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:27:16.733031137 -0500\n@@ -1124,34 +1124,10 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n-    JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1707/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-02 06:27:16.733031137 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return TRUE;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1146, 
          "faulty": "JSType previous=map.get(template);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1665/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:45.232929262 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 05:54:28.183329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1665/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-02 06:26:45.236929274 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1128, 
          "faulty": "Node declParam=declParams.next();", 
          "type": "InsertBefore", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_429/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:08:22.517592606 -0500\n@@ -1038,11 +1038,9 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1062,54 +1060,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1076,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1083,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1786/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:28:14.553216748 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1348,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1151, 
          "faulty": "JSType join=previous.getLeastSupertype(resolved);", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_485/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:09:07.505732198 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_273/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:06:02.185185623 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      int index = -1;\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1116,8 +1117,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1685/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:59.564975290 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1062,54 +1063,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1079,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 05:54:28.179329267 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1685/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-02 06:26:59.568975304 -0500\n@@ -685,7 +685,8 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n+        final String paramName = \"jscomp_throw_param\";\n+\t\tregisterIfMismatch(paramItA.next().getJSType(),\n             paramItB.next().getJSType(), error);\n       }\n \n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "InsertBefore", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1520/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:24:43.776536061 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_952/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:16:36.390945486 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "formatPreamble();"
        }
      ]
    }, 
    {
      "diff": "--- /tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 05:54:30.851329143 -0500\n+++ /tmp/GenProg_Defects4J_Closure_112/patches_1e4m/Patch_1643/patched/tmp/GenProg_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-02 06:26:28.708876761 -0500\n@@ -1038,7 +1038,8 @@\n \n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n-      Node obj = callTarget.getFirstChild();\n+      StringBuilder builder = new StringBuilder();\n+\tNode obj = callTarget.getFirstChild();\n       maybeResolveTemplatedType(\n           fnType.getTypeOfThis(),\n           getJSType(obj),\n@@ -1124,34 +1125,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n", 
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "final String paramName=\"jscomp_throw_param\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1041, 
          "faulty": "Node obj=callTarget.getFirstChild();", 
          "type": "InsertBefore", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ]
    }
  ]
}