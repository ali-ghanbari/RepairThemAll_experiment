{
  "repair_end": "2018-12-01 15:35:04.087827", 
  "repair_begin": "2018-12-01 15:01:32.917303", 
  "patches": [
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2214/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:42.022508264 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1947/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:26:13.965748213 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1947/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:13.965748213 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2507/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:30.715470752 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1046,10 +1045,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1053,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_272/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:49.924549994 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1100,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1199/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:24.027603920 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2574/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:32:07.035683790 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2574/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:07.035683790 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1367/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:20:53.772034239 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1367/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:53.776034257 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1745/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:24:23.253123359 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1745/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:23.257123383 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2773/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:55.704286715 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2614/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:32:29.475812203 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2614/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:29.475812203 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1859/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:25:27.917495756 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1859/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:27.921495778 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1100,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2848/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:38.492513009 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1071,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1100,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1514/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:16.296412860 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_866/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:16:29.934681245 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_866/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:29.938681268 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1821/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:25:07.177378792 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1821/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:07.177378792 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2743/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:39.836201390 -0500\n@@ -1058,87 +1058,18 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_692/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:14:54.478096646 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_692/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:54.482096671 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1136/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:51.247440464 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2868/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:34:48.988567749 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2868/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:48.992567771 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_841/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:17.262607650 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2086/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:27:25.058121560 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2086/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:25.058121560 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2600/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:21.271765522 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2830/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:29.648466660 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1099,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1309/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:23.063889502 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1296/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:16.251857066 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2526/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:40.343527892 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2737/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:36.668184255 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_76/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:08:59.351927208 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_76/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:59.355927232 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1433/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:34.148221198 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1098,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_950/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:14.710933109 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_116/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:24.080074366 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_116/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:24.080074366 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_467/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:39.429217663 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1895/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:46.357597990 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_236/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:31.224450512 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_260/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:43.920518278 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_939/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:08.934901288 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2806/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:13.216379970 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_429/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:19.677083396 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2325/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:29:38.398782704 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2325/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:38.398782704 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2415/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:40.583164526 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_719/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:15:09.414193144 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_719/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:09.418193169 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1170/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:08.607527506 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_739/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:19.134254847 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2049/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:06.842027561 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1130,14 +1127,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1599/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:22:58.668602479 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1599/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:58.668602479 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2852/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:40.444523211 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2017/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:50.209940781 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1143,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_562/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:13:38.065592961 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_562/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:13:38.069592986 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_562/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:38.069592986 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2406/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:35.751134170 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2726/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:33:29.436145015 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2726/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:29.440145037 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1356,7 +1353,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_976/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:17:27.323001952 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n@@ -106,7 +105,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_976/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:27.327001974 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2703/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:17.084077574 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_473/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:42.301236832 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1092,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1487/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:02.652351172 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1145,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1201/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:19:24.975608591 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1201/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:24.979608611 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2408/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:36.699140138 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_296/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:03.732622157 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_352/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:39.992806879 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,33 +1121,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2633/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:39.123866725 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1252/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:51.931740204 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1149/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:58.015474531 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_357/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:42.900821413 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2751/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:43.764222586 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2642/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:43.859893346 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1110/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:18:37.579371129 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1110/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:37.579371129 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1520/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:19.148425714 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1410/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:21.800164393 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_160/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:48.764216374 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_160/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:48.764216374 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1888/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:42.429576346 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2317/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:34.462763748 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_948/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:13.762927899 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1146,7 +1142,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1632/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:16.188709276 -0500\n@@ -1116,42 +1116,17 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1099/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:31.703341093 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1489/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:03.628355596 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1876/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:36.605544122 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1610/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:04.560634010 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1548/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:22:33.616490711 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1548/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:33.616490711 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,10 +1124,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1145,12 +1139,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2442/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:56.143261227 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1101,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_649/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:14:32.133948239 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_649/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:32.133948239 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_784/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:45.110415779 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_856/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:25.034652916 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2294/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:22.010703584 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2543/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:49.315580696 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2597/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:32:19.343754507 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2597/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:19.343754507 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1949/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:14.921753357 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2720/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:26.572129426 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_640/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:27.225914955 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_425/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:17.761070139 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2192/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:28:30.418450929 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2192/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:30.418450929 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1570/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:44.148537816 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2344/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:29:48.962833445 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2344/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:48.966833465 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_319/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:11:20.500708406 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_319/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:20.504708426 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1144,14 +1137,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1464/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:50.404295513 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2159/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:05.862328525 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_696/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:56.418109298 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1078,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2400/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:30:26.855077867 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2400/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:26.855077867 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1076,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_984/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:31.199022938 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1096,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1133/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:18:49.231430283 -0500\n@@ -112,7 +112,7 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n+        return false;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1133/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:49.231430283 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2334/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:43.142805515 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2509/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:31.667476424 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1643/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:23:27.100778905 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1643/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:27.100778905 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1128,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n@@ -1146,7 +1136,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1359/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:49.964016417 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "this.sourceName=sourceName;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_690/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:14:53.494090215 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_690/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:53.494090215 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2763/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:49.804255084 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_379/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:53.588899125 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2173/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:14.610372304 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2558/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:58.019631530 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1304/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:20.127875537 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1700/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:59.172978329 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2262/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:05.854625074 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_371/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:49.644870535 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2258/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:03.006611178 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2856/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:42.364533236 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2301/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:25.878722304 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1924/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:01.161678947 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2671/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:00.375985462 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_359/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:43.856828212 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_27/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:17.159668561 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1562/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:40.300520625 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1840/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:25:17.157435347 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1840/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:17.157435347 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2310/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:30.618745206 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1993/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:26:37.585874268 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1993/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:37.585874268 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1591/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:54.836585445 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_941/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:17:09.902906634 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_941/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:09.902906634 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1254/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:19:52.887744830 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1254/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:52.887744830 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,29 +1112,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2182/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:25.526426662 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_782/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:44.062409393 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1078,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2811/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:16.364396636 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_793/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:49.946445136 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1281/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:20:07.439814918 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1281/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:07.439814918 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1528/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:22.988442999 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,8 +1112,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1186/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:19:17.327570818 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1186/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:19:17.327570818 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1186/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:17.327570818 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2238/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:28:53.462564490 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2238/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:53.462564490 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1641/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:26.084772461 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1181/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:14.347556047 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_183/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:02.768294943 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2113/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:40.502200453 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_449/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:12:29.685151966 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_449/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:29.689151993 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_114/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:23.084068536 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1147,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2203/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:28:36.058478835 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2203/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:36.062478855 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1067/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:15.155255733 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_709/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:15:03.634156047 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_709/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:03.638156072 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2156/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:04.022319292 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1232/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:41.283688489 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1062,62 +1058,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2818/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:21.592424254 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_471/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:41.333230381 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2283/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:16.358676178 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1736/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:18.453094749 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1710/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:04.901013176 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_202/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:12.772350239 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_662/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:38.849993377 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2528/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:41.291533491 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2222/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:45.838527051 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_893/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:16:44.606765128 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_893/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:16:44.606765128 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_893/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:44.610765150 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_772/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:15:38.174373351 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_772/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:15:38.174373351 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_772/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:38.178373376 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2421/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:43.467182569 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_483/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:48.141275546 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2561/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:00.051643343 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_554/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:33.277563500 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_682/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:49.550064342 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_256/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:42.012508156 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2270/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:09.654643587 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2846/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:37.520507926 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2611/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:27.395800396 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2722/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:27.540134698 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_717/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:08.434186875 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2207/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:28:38.086488852 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2207/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:38.090488871 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1302/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:19.099870642 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2254/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:01.094601841 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1814/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:03.213356184 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2650/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:48.663920252 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_88/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:08.183980361 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_88/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:08.187980384 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2107/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:27:37.638185876 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2107/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:37.638185876 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1882/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:25:39.493560121 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1882/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:39.493560121 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_177/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:58.784272731 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1706/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:02.993001593 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1960/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:20.701784384 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1062,54 +1058,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1564/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:41.264524934 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_608/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:09.277791003 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1653/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:31.992809818 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1676/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:45.448893912 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1203/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:19:25.943613357 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1203/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:25.943613357 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2640/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:42.911888024 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1758/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:30.101163926 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_538/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:24.493508938 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2205/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:37.078483874 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1347/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:43.087984148 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2007/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:44.433910419 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1743/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:22.301117696 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2487/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:20.279408239 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_279/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:10:53.992571365 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_279/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:53.996571385 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2759/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:47.780244206 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2718/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:25.628124282 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1093/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:28.815326279 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1387/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:09.436107195 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2860/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:45.160547818 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2074/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:19.294091930 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1898/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:48.369609050 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1072,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2786/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:02.756324380 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1090,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_804/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:15:55.726479984 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_804/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:15:55.730480008 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_804/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:55.730480008 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1689/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:53.244942029 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_731/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:15.150229658 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2876/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:52.800587560 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1851/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:23.125468924 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1093,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_144/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:40.864171428 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_144/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:09:40.864171428 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_144/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:40.864171428 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_46/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:08:33.215765792 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_46/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:08:33.215765792 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_46/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:33.215765792 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2150/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:28:01.074304479 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2150/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:01.074304479 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1884/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:40.445565386 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2710/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:20.876098336 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1560/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:39.348516370 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1092,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1101/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:18:32.711346256 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1101/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:32.711346256 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1703/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:01.136990303 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1132,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2447/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:59.027278980 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2884/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:34:56.732607958 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2884/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:56.732607958 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1046,10 +1045,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1119,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1356,7 +1336,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_367/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:47.696856339 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1756/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:29.149158304 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_304/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:07.548641916 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1145/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:56.083464824 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2822/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:23.928436569 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1012/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:17:46.931107327 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1012/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:46.931107327 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_125/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:29.932108457 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_264/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:46.036529479 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2790/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:34:04.648334459 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2790/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:04.652334480 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2664/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:56.459963720 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2035/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:58.877986125 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2299/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:24.930717719 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_344/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:35.100782338 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2347/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:29:50.902844412 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2347/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:50.902844412 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_130/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:09:32.896125621 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_130/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:32.896125621 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1130,14 +1126,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n@@ -1168,7 +1156,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_443/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:12:26.661131366 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_443/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:26.661131366 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1304,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1403/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:17.972146720 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1163,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1119/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:42.447395907 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1334/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:36.359952461 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1681/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:48.380912058 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2541/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:48.339574972 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_411/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:10.145017018 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1937/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:09.161722305 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1524/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:22:21.056434305 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1524/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:21.060434324 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_44/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:32.195759362 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1124,21 +1123,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_737/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:18.170248765 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1318/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:27.843912190 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1624/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:23:12.324684389 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1624/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:12.328684415 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1343/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:41.159975080 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_396/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:02.500963006 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2097/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:30.802150985 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_897/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:46.578776298 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1119,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1145,12 +1134,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2545/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:50.263586251 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_409/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:09.193010329 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_338/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:31.148762429 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1778/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:24:45.909256494 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1778/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:45.913256517 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_968/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:23.418980734 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1398/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:15.136133605 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1034/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:58.423168200 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_67/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:53.135889388 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n@@ -1168,7 +1167,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_92/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:09:10.155992137 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_92/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:10.159992160 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_174/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:09:56.748261338 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_174/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:56.748261338 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2171/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:13.658367549 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_864/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:28.970675685 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2491/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:31:22.111419258 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n@@ -114,7 +113,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2184/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:26.474431369 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2139/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:55.110274441 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_849/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:21.106630090 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_156/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:46.836205447 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_156/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:46.836205447 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1351,7 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n+        return null;\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_770/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:37.194367325 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2105/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:36.686181025 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,18 +1124,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2461/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:31:07.615331540 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2461/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:07.615331540 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2178/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:28:22.598412111 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2178/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:22.602412131 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_340/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:32.108767272 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_390/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:59.500941613 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2788/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:03.700329410 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1234/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:42.231693107 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2549/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:52.163597371 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2694/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:12.296051284 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1320/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:28.791916682 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1325/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:31.655930239 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_361/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:44.804835174 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_70/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:55.103901400 -0500\n@@ -1146,10 +1146,8 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1771/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:41.985233653 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2014/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:48.277930639 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2246/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:28:57.298583279 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2246/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:57.298583279 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1073/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:18:18.055270777 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1073/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:18.055270777 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_262/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:44.960523787 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2777/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:57.808297968 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_165/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:51.792233481 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1116,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_335/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:11:29.220752688 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_335/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:29.224752709 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1128,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n@@ -1145,12 +1135,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2266/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:07.754634334 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,8 +1112,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_566/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:13:40.197606016 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_566/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:40.197606016 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2724/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:28.480139815 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1732/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:16.529083241 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1050/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:06.431210252 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2051/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:07.798032521 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1356,7 +1330,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1040/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:01.307183379 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1968/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:24.633805414 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_274/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:50.884555045 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_703/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:00.650136774 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2662/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:32:55.511958446 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2662/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:32:55.511958446 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2662/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:55.511958446 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_588/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:56.833706600 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2276/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:12.546657657 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1426/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:30.400203989 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_818/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:04.426531964 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2009/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:26:45.393915474 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2009/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:45.393915474 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2200/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:34.214469720 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1991/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:26:36.625869186 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1991/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:36.625869186 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2489/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:21.227413944 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2383/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:17.239016375 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_39/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:08:29.315741150 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_39/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:29.315741150 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_548/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:29.437539731 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1046,10 +1045,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,8 +1111,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_270/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:10:48.936544788 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_270/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:48.940544809 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_745/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:22.378275254 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1147,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1861/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:25:28.877501118 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1861/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:28.881501141 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_140/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:38.888160114 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_60/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:48.163858886 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_991/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:35.075043846 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_688/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:52.526083878 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1208/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:19:28.899627895 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1208/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:28.903627915 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1075,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2609/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:26.351794462 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2100/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:32.910161759 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1166/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:06.695517973 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_373/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:50.600877484 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1420/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:27.540190838 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1131,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2365/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:01.574914743 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2353/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:54.802870219 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_29/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:18.163672202 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1188/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:18.279575531 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_11/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:05.335625647 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_137/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:09:36.972149115 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_137/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:36.972149115 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2838/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:33.688487859 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2500/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:26.883447869 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,10 +1143,8 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2606/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:24.139781875 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_135/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:35.808142418 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1098,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_37/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:28.315734807 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2250/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:59.202592593 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_223/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:10:24.364413485 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_223/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:24.364413485 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1082,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2076/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:20.242096810 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_152/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:44.792193834 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1122,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1385/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:21:08.488102794 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1385/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:08.488102794 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_759/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:31.298330906 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1357/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:49.012011956 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2337/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:45.082814832 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1351/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:46.039998016 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2799/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:09.428359876 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2832/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:30.836472898 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_964/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:17:21.494970247 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_964/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:21.494970247 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1838/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:16.177429816 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_735/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:17.182242523 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1300/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:18.147866107 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_913/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:55.370825808 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_751/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:26.238299420 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2371/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:10.542973156 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1534/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:25.832455784 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1462/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:49.444291138 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1291/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:13.351843218 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1910/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:54.265641356 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_120/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:09:27.000091410 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_120/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:27.004091435 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2765/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:33:50.872260817 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2765/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:50.872260817 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1503/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:10.476386586 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1124,21 +1123,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_240/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:33.140460801 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_492/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:53.033307705 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2471/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:12.379360504 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2532/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:43.279545218 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1270/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:01.779787729 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2530/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:31:42.331539629 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2530/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:42.335539652 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_659/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:14:36.941980602 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_659/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:36.945980629 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1928/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:03.073689335 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_542/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:26.573521920 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_162/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:49.844222483 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_162/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:49.848222507 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1168/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:07.655522761 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2248/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:58.250587937 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1356,7 +1353,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2313/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:32.554754547 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1076,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1123/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:44.359405614 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2023/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:53.077955814 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1939/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:10.113727446 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1373/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:56.640047638 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_19/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:11.143646736 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2667/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:58.387974431 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1808/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:00.345339774 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1812/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:02.257350718 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_653/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:34.041961111 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_748/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:15:24.298287291 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_748/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:24.302287316 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1097,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_839/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:16.286601936 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2234/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:51.562555171 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2514/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:31:34.535493483 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n@@ -114,7 +113,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2514/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:34.535493483 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,10 +1144,8 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "this.scope=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1314/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:20:25.903902990 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1314/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:20:25.903902990 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1314/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:25.903902990 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1365/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:52.816029767 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2816/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:20.644419251 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1674/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:23:44.488887956 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1674/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:44.488887956 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2404/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:34.807128222 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_680/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:48.558057810 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1708/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:03.945007375 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2520/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:31:37.387510402 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2520/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:37.391510426 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1558/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:22:38.396512112 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1558/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:38.396512112 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2033/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:57.893980990 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2321/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:36.362772902 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1027/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:17:54.599148014 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n@@ -106,7 +105,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1027/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:17:54.599148014 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1027/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:54.603148035 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_204/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:13.756355642 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1452/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:44.604269056 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1866/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:31.793517378 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1566/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:42.240529295 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1665/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:39.752858479 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2456/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:04.791314307 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2029/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:55.945970816 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2329/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:40.298791845 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "this.scope=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1826/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:25:09.985394756 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1826/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:09.989394778 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2001/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:41.429894582 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1144,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2804/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:12.272374966 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_505/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:05.909391206 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_546/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:28.481533793 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1383/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:21:07.532098356 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1383/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:07.532098356 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1145,12 +1141,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2220/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:44.894522407 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1450/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:21:43.652264708 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1450/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:43.652264708 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_490/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:12:52.033301151 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_490/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:52.037301177 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_825/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:16:08.334555132 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_825/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:08.334555132 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_206/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:14.712360885 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_369/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:48.688863575 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2375/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:13.398991630 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1116,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1316/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:20:26.863907543 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1316/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:26.863907543 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n@@ -1356,7 +1350,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2797/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:08.480354841 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2467/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:10.459348848 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1830/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:12.133406940 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2109/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:38.590190724 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1082/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:22.943296051 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1217/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:33.631651107 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2377/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:14.366997878 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1863/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:29.861506610 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1117,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1124,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2019/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:51.169945816 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2820/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:34:22.920431258 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2820/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:22.920431258 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2644/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:44.819898730 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1213/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:31.735641815 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1046/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:18:04.419199714 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1046/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:04.419199714 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1098,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1987/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:26:34.665858800 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1987/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:34.669858822 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1762/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:32.041175366 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_228/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:27.268429195 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1098,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1728/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:14.573071517 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1394/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:21:13.208124679 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1394/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:21:13.208124679 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1394/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:13.212124698 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1593/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:55.788589678 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_798/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:15:52.814462459 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_798/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:52.814462459 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2866/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:48.020562713 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_150/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:09:43.824188323 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_150/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:43.824188323 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1090/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:26.843316144 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_419/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:13.957043692 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1172/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:09.559532248 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1265/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:58.727773031 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,57 +1055,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1092,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2152/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:02.026309265 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2391/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:22.087047460 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2095/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:27:29.846146094 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2095/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:29.850146115 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1078,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1210/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:29.855632590 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2043/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:03.962012601 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1336/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:37.307956932 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_148/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:09:42.816182576 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_148/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:42.816182576 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2522/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:31:38.443516656 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2522/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:38.447516679 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1780/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:46.861262022 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1168,7 +1165,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1824/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:09.017389258 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1396/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:14.184129200 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2417/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:30:41.535170488 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2417/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:41.539170513 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_911/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:54.422820493 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_634/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:24.197894292 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1222/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:36.499665139 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1132,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_598/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:03.545750648 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2469/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:11.407354606 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_934/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:05.938884708 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1375/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:57.592052082 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_540/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:25.593515808 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2218/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:43.942517721 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_586/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:55.881700905 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1406/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:21:19.872155496 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1406/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:19.872155496 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1906/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:52.353630896 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "this.scope=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_502/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:13:04.045379217 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_502/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:04.049379243 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2679/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:04.596008829 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_674/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:14:45.674038768 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_674/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:45.678038794 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1085,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n@@ -1168,7 +1106,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2003/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:42.385899626 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_721/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:10.374199275 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_62/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:08:49.143864915 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_62/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:49.143864915 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1116,8 +1115,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_321/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:21.484713422 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1230/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:40.331683848 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2551/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:53.203603449 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1116,8 +1115,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_741/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:20.342262457 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1512/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:15.232408061 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1355/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:48.060007493 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2212/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:28:41.070503572 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2212/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:41.070503572 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1670/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:42.580876100 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_581/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:53.053683942 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2256/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:29:02.058606550 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2256/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:02.058606550 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1062,62 +1058,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2119/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:43.586216123 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_873/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:33.758703241 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1029/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:55.551153046 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1206/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:27.943623197 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1790/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:51.669289862 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1046,10 +1045,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1144,14 +1139,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1077/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:20.107281400 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1694/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:56.248960454 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1149,7 +1145,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1127/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:46.287415388 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_765/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:34.254349201 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_534/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:22.577496947 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2479/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:16.259383994 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2767/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:51.836265990 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2677/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:33:03.452002499 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2677/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:33:03.452002499 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2677/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:03.452002499 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1970/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:26:25.621810689 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1970/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:25.621810689 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1340/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:20:39.227965983 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1340/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:39.231966001 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_325/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:11:23.392723135 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_325/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:11:23.396723154 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_325/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:23.396723154 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_142/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:39.872165752 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_142/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:09:39.876165774 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_142/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:39.876165774 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1146,7 +1145,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2708/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:19.932093173 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1932/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:06.257706597 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1568/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:43.192533547 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_830/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:11.226572206 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_725/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:12.286211463 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_835/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:16:14.254590019 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_835/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:14.254590019 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1147/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:57.039469629 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1856/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:25.997485019 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1356,7 +1341,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1112/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:38.639376533 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_699/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:58.346121836 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_619/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:15.141831895 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_314/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:11:12.472667296 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_314/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:12.476667317 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1976/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:26:28.489825980 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1976/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:28.493826001 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2454/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:03.807308291 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1088/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:25.859311080 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_860/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:26.994664267 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1730/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:15.529077250 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1516/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:17.248417152 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_365/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:11:46.744849385 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_365/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:46.744849385 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_413/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:11.097023697 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2739/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:33:37.940191139 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2739/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:37.940191139 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1589/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:53.864581120 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2483/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:18.175395561 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_868/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:30.890686753 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1117,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_570/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:13:42.121617765 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_570/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:13:42.125617789 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_570/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:42.125617789 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2264/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:06.806629714 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_78/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:00.323933090 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2350/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:52.894857609 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_439/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:24.537116835 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_958/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:18.606954468 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2657/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:52.607942272 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2274/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:29:11.598653047 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2274/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:11.598653047 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1806/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:59.373334203 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_763/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:15:33.302343316 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_763/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:33.302343316 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1143,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_529/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:19.641478506 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2216/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:42.974512954 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1798/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:55.477311820 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1844/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:19.097446280 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1149,7 +1145,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1192/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:20.183584947 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1195/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:22.107594449 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1137,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_924/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:01.162858170 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_715/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:15:07.478180752 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_715/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:07.478180752 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2749/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:42.816217476 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1129/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:18:47.243420228 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1129/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:47.247420249 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1103/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:33.759351619 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1093,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n@@ -1168,7 +1110,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1226/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:38.427674558 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_787/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:47.018427384 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_132/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:33.864131212 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1392/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:12.244120214 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2880/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:54.820598044 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1060/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:18:11.279235568 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1060/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:11.283235589 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2516/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:35.483499112 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_972/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:17:25.330991135 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_972/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:25.334991157 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2485/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:19.127401301 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1724/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:12.649059960 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1446/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:41.720255877 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1153/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:59.923484104 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_454/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:32.641172005 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1184/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:16.355566003 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_779/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:42.170397842 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1401/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:17.020142319 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1158,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2121/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:44.538220955 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,10 +1124,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2747/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:41.840212210 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,8 +1112,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1124,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2891/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:35:00.532627633 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2631/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:38.175861386 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_104/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:17.044033015 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1143,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2692/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:11.332045980 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2080/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:22.174106747 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_921/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:59.218847331 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2021/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:26:52.125950826 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2021/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:52.129950848 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1849/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:22.053462906 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_638/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:26.137907541 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_300/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:05.640632046 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2082/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:23.130111660 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2697/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:14.212061814 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1414/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:21:23.708173192 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1414/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:23.708173192 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2176/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:21.642407355 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2411/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:38.587152005 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1639/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:25.136766443 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_899/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:47.562781863 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2775/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:33:56.752292322 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2775/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:56.756292343 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1912/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:55.245646711 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_584/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:13:54.913695106 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_584/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:54.913695106 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1094,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_194/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:10:08.496326686 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_194/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:08.496326686 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_190/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:06.560315982 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_733/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:16.230236500 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1958/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:19.653778768 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1088,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_956/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:17.654949257 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1155/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:00.915489076 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1713/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:06.861025048 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1505/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:11.428390889 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,10 +1121,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2196/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:32.318460338 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1626/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:13.288690609 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1093,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2652/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:32:49.615925573 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2652/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:49.615925573 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2130/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:49.334245258 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1536/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:26.784460061 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_550/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:13:30.389545636 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_550/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:30.393545661 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2398/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:25.903071809 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_523/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:16.645459609 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1509/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:13.332399487 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2296/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:23.066708698 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1108,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_247/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:37.120482103 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_168/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:53.832244969 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1130,14 +1127,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_527/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:18.661472334 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_670/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:43.650025353 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1062,54 +1061,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2755/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:45.780233446 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_42/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:31.203753098 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1147,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2741/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:38.888196265 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1556/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:37.444507852 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_604/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:07.373777640 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2565/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:02.235656016 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2583/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:32:11.791711200 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2583/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:11.791711200 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_858/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:16:25.998658502 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_858/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:16:25.998658502 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_858/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:26.002658526 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_348/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:37.984796820 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1659/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:35.880834255 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2342/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:48.014828900 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1075/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:19.155276474 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_558/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:36.145581170 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_592/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:58.793718305 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2057/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:10.682047465 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_277/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:53.032566329 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1168,7 +1165,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_53/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:44.335835246 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,18 +1124,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n@@ -1145,12 +1131,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2585/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:32:12.763716789 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2585/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:12.763716789 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1518/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:18.200421443 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_216/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:10:20.516392586 -0500\n@@ -618,7 +618,7 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n+      return false;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_216/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:20.520392608 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1144,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1985/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:33.713853750 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_891/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:43.638759636 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1097/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:18:30.723336070 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1097/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:30.723336070 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2025/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:26:54.033960818 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2025/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:54.037960838 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2627/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:36.155849996 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_127/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:30.936114278 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_127/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:30.940114302 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2307/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:28.718736031 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_814/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:02.406519946 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1353/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:47.084002915 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2681/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:05.552014110 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1304,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1698/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:58.220972515 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1684/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:50.372924352 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,10 +1124,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_461/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:36.501198030 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1092,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_22/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:08:13.231654313 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_22/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:13.231654313 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_465/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:38.437211022 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1238/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:44.163702511 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_623/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:17.145845781 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2518/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:36.435504760 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1098,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1784/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:48.765273062 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2093/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:28.870141099 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1100,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_757/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:15:30.158323832 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_757/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:30.158323832 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_854/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:24.082647394 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1298/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:17.199861588 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1143,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1532/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:24.880451506 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2505/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:29.771465123 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2591/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:15.619733184 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1460/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:48.436286542 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1916/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:25:57.285657844 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1916/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:25:57.285657844 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1916/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:57.289657866 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1168,7 +1164,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_198/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:10:10.688338775 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_198/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:10:10.688338775 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_198/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:10.692338798 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1635/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:23:23.224754281 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1635/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:23.228754306 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2842/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:35.604497897 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1542/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:29.692473117 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_392/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:00.456948442 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1128,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_109/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:19.936050059 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_100/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:14.948020618 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1160,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1792/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:52.617295336 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1764/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:24:33.021181137 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1764/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:33.021181137 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1163/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:04.775508388 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_723/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:11.326205348 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1668/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:41.628870175 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1082,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2279/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:14.462666970 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2712/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:21.824103519 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1116/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:40.543386227 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2360/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:29:58.734896115 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2360/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:58.734896115 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1474/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:21:55.452318486 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1474/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:55.452318486 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_820/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:05.382537642 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_316/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:13.428672209 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2638/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:32:41.959882677 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2638/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:41.963882701 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1550/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:34.564494958 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_456/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:33.593178438 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1101,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1220/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:35.551660504 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1093,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_945/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:11.810917156 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,8 +1112,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_632/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:23.073886596 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1091,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2039/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:00.909996718 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1068,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_266/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:47.000534573 -0500\n@@ -1062,96 +1062,25 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_932/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:04.990879451 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1307/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:22.115884996 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1832/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:25:13.121412537 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1832/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:13.121412537 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1119,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1084/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:23.895300962 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2477/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:15.311378263 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1121/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:43.403400762 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1583/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:51.004568388 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1989/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:26:35.641863974 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1989/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:35.645863995 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_268/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:10:47.964539662 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_268/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:47.964539662 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1303,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_332/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:27.312743031 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1146,10 +1142,8 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1914/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:56.305652498 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2659/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:53.611947868 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_572/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:43.077623591 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1696/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:57.220966403 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1122,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2801/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:34:10.384364951 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2801/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:10.384364951 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1054/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:18:08.335220207 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1054/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:08.335220207 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1125/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:45.335410563 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2161/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:06.842333439 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1150,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1964/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:22.717795174 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1545/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:31.612481730 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_668/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:42.666018817 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1157,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1389/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:10.388111610 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1156,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1572/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:22:45.108542101 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1572/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:45.108542101 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_843/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:18.218613240 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_904/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:50.518798544 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_917/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:57.314836692 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_943/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:10.854911887 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_997/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:39.111065536 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1966/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:23.669800263 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_686/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:14:51.570077613 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_686/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:14:51.574077639 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_686/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:51.574077639 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_789/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:48.026433503 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2840/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:34.656492932 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1647/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:29.016791034 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1501/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:22:09.500382174 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1501/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:09.504382193 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1412/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:21:22.756168802 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1412/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:22.760168822 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_58/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:47.195852921 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1354,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1614/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:06.472646464 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1908/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:53.309636128 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1096,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_355/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:41.948816660 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_694/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:55.458103042 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_560/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:37.097587020 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1972/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:26.573815768 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2444/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:57.095267093 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1454/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:45.556273402 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_154/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:45.756199315 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2440/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:55.103254812 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2716/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:24.684119134 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_288/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:58.820596607 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1044/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:03.267193672 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2864/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:34:47.056557695 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2864/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:47.056557695 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2473/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:31:13.407366736 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2473/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:13.411366761 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1259/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:55.735758595 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2874/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:51.852582637 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1250/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:50.983735614 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1094,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1953/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:16.825763593 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_978/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:28.279007135 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_701/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:59.370128482 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2186/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:27.422436074 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1128,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2385/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:30:18.187022467 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2385/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:18.191022493 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1018/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:49.787122515 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_889/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:42.686754229 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1139/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:53.167450146 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_776/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:15:40.130385355 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_776/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:15:40.134385380 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_776/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:40.134385380 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2111/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:27:39.546195590 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2111/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:39.550195610 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1031/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:17:56.507158095 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1031/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:56.507158095 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1157/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:01.863493824 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_672/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:14:44.706032357 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_672/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:44.710032384 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_221/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:23.400408258 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1116,8 +1115,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2224/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:46.786531714 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1215/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:32.683646462 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_791/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:15:48.990439347 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_791/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:48.990439347 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2481/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:17.211389744 -0500\n@@ -1058,87 +1058,18 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1077,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1263/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:57.751768325 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1361/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:50.916020875 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2690/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:10.380040740 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1436/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:21:36.052229928 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1436/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:36.052229928 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_727/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:13.238217519 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1092,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2889/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:34:59.580622707 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2889/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:59.584622727 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1128,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2126/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:27:47.426235597 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2126/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:27:47.426235597 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2126/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:27:47.430235617 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2126/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:47.430235617 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1552/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:35.544499347 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_245/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:36.060476438 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1097,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1918/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:58.245663077 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_97/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:13.008009111 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1114/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:39.595381402 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2705/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:18.036082792 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1078,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_729/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:14.194223592 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_421/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:14.917050383 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1168,7 +1164,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1800/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:24:56.429317298 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1800/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:56.429317298 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_350/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:38.940801611 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1116,8 +1115,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2425/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:45.419194750 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_56/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:46.191846725 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2571/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:05.087672532 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1168,7 +1165,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_254/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:41.056503075 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_895/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:45.586770682 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1408/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:20.848160002 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_441/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:25.513123519 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1672/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:43.528881994 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_83/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:04.299957069 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_83/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:09:04.303957092 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_83/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:04.303957092 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1166,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_447/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:28.581144457 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_258/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:42.968513231 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_816/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:16:03.466526256 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_816/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:03.466526256 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2635/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:40.095872197 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1145,12 +1141,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2731/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:32.328160728 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_122/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:27.976097093 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2784/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:34:01.808319326 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2784/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:01.808319326 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1168,7 +1161,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_510/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:08.833409943 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1160,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1323/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:30.699925716 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2437/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:30:53.247243347 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2437/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:53.247243347 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2232/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:50.614550520 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,29 +1112,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2061/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:12.586057315 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2226/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:47.742536413 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2701/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:16.132072354 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_463/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:12:37.461204477 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_463/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:37.461204477 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_579/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:52.097678193 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1522/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:22:20.104430019 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1522/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:20.104430019 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_192/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:07.512321248 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2435/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:52.171236691 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1810/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:25:01.305345272 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1810/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:01.309345294 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_642/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:28.197921567 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2581/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:10.831705676 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_532/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:21.569490624 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_902/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:49.566793177 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_458/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:34.549184888 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1466/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:51.376299939 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,10 +1072,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2053/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:08.778037601 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1161/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:03.799503510 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2753/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:44.736227825 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1128,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_676/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:46.630045089 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1010/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:45.967102192 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2463/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:08.567337339 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2625/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:35.207844644 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1726/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:13.601065681 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1870/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:33.729528151 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2379/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:15.339004145 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_431/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:20.661090188 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1088,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "this.scope=null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_437/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:12:23.577110251 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_437/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:12:23.577110251 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_437/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:23.581110279 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_327/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:11:24.356728034 -0500\n@@ -618,7 +618,7 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n+      return false;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_327/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:24.360728055 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2895/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:35:02.456637582 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2895/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:35:02.456637582 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1124,34 +1120,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1663/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:38.800852534 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "this.sourceName=sourceName;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1056/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:18:09.367225595 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1056/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:18:09.367225595 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1056/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:09.367225595 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_158/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:47.796210892 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_377/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:52.596891953 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2355/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:55.746876447 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_312/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:11:11.504662317 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_312/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:11.508662338 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2616/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:30.423817579 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_400/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:04.400976498 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_712/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:15:05.566168481 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_712/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:05.566168481 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2327/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:39.350787285 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2190/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:29.330445537 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_394/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:01.460955602 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1144,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2536/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:45.203556547 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2005/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:43.373904835 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1272/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:02.731792309 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1142,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2012/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:47.325925636 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2063/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:27:13.546062278 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2063/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:13.546062278 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_243/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:35.100471304 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_907/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:16:52.458809462 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_907/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:52.462809485 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2459/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:06.643325614 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1538/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:27.768464481 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1926/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:02.121684165 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2893/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:35:01.480632537 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_960/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:19.558959674 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1283/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:08.387819462 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1747/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:24.205129017 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1369/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:54.744038783 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1580/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:22:49.096559887 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1580/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:49.100559904 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2369/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:09.546966699 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2493/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:31:23.063424976 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2493/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:23.067425000 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1997/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:39.493884358 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2686/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:33:08.360029609 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2686/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:08.360029609 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1750/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:26.193140811 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_306/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:08.504646854 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_862/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:27.966669887 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1978/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:29.449831091 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1144,14 +1143,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_445/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:27.625137944 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_230/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:28.360435088 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_909/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:53.410814812 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_200/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:11.816344985 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2779/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:58.756303035 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1065/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:14.171250620 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_982/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:30.207017574 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_32/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:20.163682726 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_375/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:51.640885029 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_970/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:24.370985915 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1098,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_402/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:05.352983240 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2675/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:33:02.491997187 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2675/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:02.491997187 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_508/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:07.857403698 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1828/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:11.153401384 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_404/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:06.300989945 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2423/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:30:44.439188637 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2423/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:44.443188662 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1108/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:18:36.615366211 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1108/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:18:36.619366232 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1108/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:36.619366232 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1058/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:10.319230564 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1130,14 +1126,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1020/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:17:50.767127717 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1020/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:50.771127738 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1804/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:58.377328488 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1327/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:32.603934722 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2622/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:33.387834359 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1257/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:54.783753996 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_887/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:41.718748725 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1062,62 +1058,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1767/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:40.085222561 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2887/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:34:58.620617738 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2887/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:58.620617738 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1874/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:35.633538728 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_767/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:35.202355053 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1934/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:26:07.229711859 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1934/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:26:07.229711859 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1934/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:07.229711859 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1071,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2394/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:23.991059622 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_915/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:16:56.358831343 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_915/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:16:56.362831366 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_915/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:56.362831366 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1139,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_885/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:40.762743284 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1776/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:44.837250263 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2078/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:21.194101708 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2495/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:31:24.011430665 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2495/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:24.015430689 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1052/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:07.383215231 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_544/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:27.529527873 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2194/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:31.370455644 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_90/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:09.155986170 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1130,14 +1127,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1722/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:11.697054233 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_974/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:26.286996329 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1716/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:08.833036968 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n@@ -1168,7 +1145,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_281/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:10:54.984576561 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_281/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:54.984576561 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2699/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:15.160067020 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1091,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2728/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:30.416150343 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1130,28 +1126,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1892/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:44.453587507 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2244/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:28:56.310578442 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2244/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:56.314578462 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,34 +1121,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1071/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:17.099265821 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_310/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:10.440656838 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1441/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:38.924243084 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2303/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:26.826726888 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_928/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:03.094868922 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_515/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:11.777428727 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2655/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:51.571936494 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_832/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:12.194577907 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1116,8 +1112,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_761/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:32.294337078 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1174/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:10.523537046 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_754/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:28.218311767 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1311/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:24.015894026 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1603/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:00.612611113 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2502/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:31:27.839453586 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2502/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:27.839453586 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1126,18 +1122,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n@@ -1149,7 +1133,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2065/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:14.498067196 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1846/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:20.049451640 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1038/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:00.359178393 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1293/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:14.323847862 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1097,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_879/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:37.662725599 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2452/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:02.855302464 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_286/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:57.868591640 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2563/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:01.119649543 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_107/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:18.972044385 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1097,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_495/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:13:00.145354027 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_495/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:00.149354053 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1145,12 +1138,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2862/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:46.108552758 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2289/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:19.222690073 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_185/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:03.736300323 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1092,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1379/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:59.516061057 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_214/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:19.524387184 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_627/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:14:20.173866677 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_627/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:20.173866677 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1995/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:26:38.545879346 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1995/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:38.545879346 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2432/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:50.275224944 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,58 +1057,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1071,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_308/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:11:09.464651807 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_308/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:09.464651807 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_433/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:21.613096748 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1796/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:54.525306338 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1448/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:42.696260339 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1075,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1247/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:48.939725708 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1608/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:23:03.568627536 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1608/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:03.568627536 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_211/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:10:17.612376752 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_211/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:17.612376752 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1868/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:32.773522833 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_469/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:40.381224026 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1760/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:24:31.077169684 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1760/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:31.081169708 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1100,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_481/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:47.189269259 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2188/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:28:28.374440796 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2188/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:28.378440816 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1078,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1495/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:06.484368531 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_170/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:54.796250387 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1130,14 +1127,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2511/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:32.635482187 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1275/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:04.575801171 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1618/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:08.384658886 -0500\n@@ -1039,17 +1039,9 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2090/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:26.966131345 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1130,14 +1126,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2795/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:07.536349824 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1159/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:02.819498608 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_234/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:30.268445369 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1144,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n@@ -1168,7 +1165,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_952/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:17:15.674938402 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_952/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:15.674938402 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1090,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n@@ -1168,7 +1111,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1438/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:21:37.012234327 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1438/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:37.012234327 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2230/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:49.634545708 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_384/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:56.616920941 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1507/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:12.380395188 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_427/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:12:18.721076787 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_427/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:18.721076787 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1001/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:41.079076082 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2629/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:37.207855930 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_232/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:29.312440220 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1014/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:17:47.887112415 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1014/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:47.887112415 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1036/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:59.383173257 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1116,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_655/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:34.997967547 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2168/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:11.654357533 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2055/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:09.730042535 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_657/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:35.949973945 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,33 +1072,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1601/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:22:59.640606798 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1601/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:59.644606815 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_196/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:09.616332866 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1354,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1645/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:28.064785011 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2292/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:21.058698973 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1062,54 +1058,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1074,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2595/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:32:18.387749039 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2595/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:18.387749039 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1493/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:05.528364203 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_519/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:14.709447352 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1345/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:20:42.135979672 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1345/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:42.139979691 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2071/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:17.390082120 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1630/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:15.232703130 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2547/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:51.215591825 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_647/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:31.081941128 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1782/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:47.813267545 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_610/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:10.233797696 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1842/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:25:18.141440895 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1842/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:18.145440917 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2538/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:46.335563203 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_417/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:12:13.005037048 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_417/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:13.005037048 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1983/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:32.665848188 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1458/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:47.460282091 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1794/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:53.569300828 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1279/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:20:06.487810350 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1279/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:06.487810350 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_291/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:11:00.732606568 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_291/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:00.732606568 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2524/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:39.395522288 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_452/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:31.657165345 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_601/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:14:05.413763841 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_601/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:05.413763841 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1134,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1853/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:25:24.089474331 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1853/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:24.093474353 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2084/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:24.078116529 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_485/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:49.229282718 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1526/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:22.032438698 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1147,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1890/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:43.409581752 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1095,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1595/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:56.744593929 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1144,14 +1143,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1974/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:27.529820865 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1168,7 +1165,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_774/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:39.126379198 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1197/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:23.059599146 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_577/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:13:51.133672389 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_577/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:51.137672413 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2045/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:04.914017549 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1836/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:15.033423353 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1878/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:25:37.585549555 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1878/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:37.585549555 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_966/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:22.450975460 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,33 +1120,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1955/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:17.777768704 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_564/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:13:39.241600166 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_564/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:39.241600166 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_513/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:10.817422611 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_435/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:22.589103465 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1131/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:48.199425066 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_847/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:20.130624402 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1886/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:41.477571089 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1086/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:18:24.847305869 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1086/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:24.847305869 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1428/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:31.348208344 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1999/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:40.473889535 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_636/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:25.145900772 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2870/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:49.936572679 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1497/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:07.460372948 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2745/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:40.892207093 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1146,7 +1142,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_988/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:33.103033219 -0500\n@@ -1062,54 +1062,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1084,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_536/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:23.533502933 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1139,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_74/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:08:58.343921098 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_74/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:58.343921098 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1142,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_284/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:56.912586647 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1093,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_252/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:40.104498012 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1116,8 +1115,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1127,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1880/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:38.537554828 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_630/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:22.093879876 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_525/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:13:17.701466279 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_525/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:17.701466279 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1179/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:13.367551182 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2323/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:29:37.438778083 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2323/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:29:37.438778083 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2323/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:37.442778102 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2165/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:28:09.638347446 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2165/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:09.638347446 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,34 +1072,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1224/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:37.475669909 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2850/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:39.476518154 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1612/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:23:05.516640241 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1612/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:05.520640267 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2556/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:57.071626011 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_363/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:45.784842359 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1190/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:19.231580240 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_323/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:22.436718270 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2688/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:09.432035518 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1046,10 +1045,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1054,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_994/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:37.111054798 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1554/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:36.492503592 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1443/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:39.876247442 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_980/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:29.231012292 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_478/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:12:45.273256578 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_478/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:45.273256578 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1062,54 +1058,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1074,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1597/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:57.692598143 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1168,7 +1165,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1106/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:35.659361330 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2396/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:30:24.955065769 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2396/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:30:24.955065769 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2396/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:24.959065795 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2305/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:27.774731470 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1130,14 +1127,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1245/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:19:47.987721090 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1245/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:47.991721109 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2576/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:07.983689262 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2236/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:28:52.510559822 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2236/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:52.514559841 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1285/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:09.363824138 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1578/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:22:48.084555376 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1578/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:48.084555376 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2602/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:22.219770931 -0500\n@@ -1062,62 +1062,14 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1692/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:55.256954377 -0500\n@@ -1059,65 +1059,14 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_497/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:13:01.133360422 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_497/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:01.133360422 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1261/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:56.687763192 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_15/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:08.327636513 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1481/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:59.704337800 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2339/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:46.030819382 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1485/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:01.652346639 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_330/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:26.356738186 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2027/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:54.985965798 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2534/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:44.231550826 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1143,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1530/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:23.936447263 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1754/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:28.125152250 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_181/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:01.796289534 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_800/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:53.766468195 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_877/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:16:36.694720064 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_877/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:36.694720064 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1131,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1042/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:02.315188672 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2128/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:27:48.382240439 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2128/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:48.386240459 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1902/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:50.413620267 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1587/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:52.904576848 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1003/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:42.031081177 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1651/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:31.036803791 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2388/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:20.167035170 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1143,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1540/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:22:28.740468845 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1540/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:28.744468862 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1024/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:52.699137959 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_238/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:32.184455669 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2569/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:04.143667070 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1371/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:55.692043211 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2059/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:11.634052391 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2673/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:01.507991736 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1079,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1431/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:33.196216829 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1951/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:15.873758477 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2252/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:00.146597208 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1095/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:18:29.767331166 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1095/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:29.767331166 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_188/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:05.596310642 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_621/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:14:16.101838552 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_621/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:16.101838552 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_102/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:15.940026489 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1574/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:46.152546759 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2882/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:55.772602980 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1616/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:07.428652679 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1075,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2124/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:46.438230590 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_795/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:50.898450893 -0500\n@@ -1124,33 +1124,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2319/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:35.410768315 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2285/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:17.306680779 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,28 +1128,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_954/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:17:16.698944019 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_954/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:16.702944041 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1802/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:57.405322907 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1468/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:52.428304730 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2287/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:18.274685476 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2141/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:56.166279766 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2088/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:26.010126443 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2228/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:48.686541052 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2135/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:53.182264711 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1456/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:46.508277747 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_684/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:14:50.610071311 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_684/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:50.610071311 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_590/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:13:57.797712360 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_590/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:57.801712385 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1304,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1769/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:41.037228122 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1943/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:12.021737741 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2465/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:09.515343108 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2648/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:32:47.691914816 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2648/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:47.691914816 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1472/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:21:54.440313884 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1472/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:54.440313884 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1147,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1656/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:23:33.968822252 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1656/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:33.968822252 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2331/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:41.246796403 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1145,12 +1141,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1962/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:26:21.665789545 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1962/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:21.665789545 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2589/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:32:14.667727723 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2589/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:32:14.667727723 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2589/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:14.671727747 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1752/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:24:27.169146593 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1752/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:27.173146617 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_488/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:51.077294876 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2809/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:34:15.244390710 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2809/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:15.244390710 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1720/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:10.741048476 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1478/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:57.656328502 -0500\n@@ -1126,18 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_209/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:10:16.640371440 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_209/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:16.640371440 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1605/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:01.588615447 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1142,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2427/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:46.391200806 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1131,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2578/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:32:08.939694776 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2578/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:08.939694776 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_386/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:57.588927920 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2358/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:57.762889725 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,33 +1072,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1267/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:59.767778044 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1130,14 +1128,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1816/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:04.165361620 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1168,7 +1166,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_837/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:15.218595676 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1153,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1063/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:18:13.223245690 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1063/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:13.223245690 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_294/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:02.648616530 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1093,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_388/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:11:58.544934772 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_388/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:58.544934772 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2210/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:40.110498839 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1141/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:54.179455244 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1144,14 +1140,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1900/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:49.441614935 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2268/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:08.706638972 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_707/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:15:02.678149882 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_707/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:02.678149882 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2878/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:53.760592543 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2834/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:31.780477853 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1016/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:48.835117457 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_678/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:14:47.598051481 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_678/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:47.602051507 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2037/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:59.833991110 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1499/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:22:08.508377689 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1499/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:08.512377707 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_828/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:16:10.270566569 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_828/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:10.274566592 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2281/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:15.410671574 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_806/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:56.690485771 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_823/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:07.314549096 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1243/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:19:47.039716488 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1243/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:47.043716507 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2381/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:16.287010250 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_871/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:16:32.802697751 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_871/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:32.802697751 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_225/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:25.324418684 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1126,10 +1123,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1287/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:10.315828698 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2587/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:13.711722234 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMap.java", 
          "line": 115, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:01:10.958036420 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_407/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMap.java\t2018-12-01 09:12:08.221003489 -0500\n@@ -112,7 +112,6 @@\n     // Note: match by identity, not equality\n     for (TemplateType entry : templateKeys) {\n       if (entry == templateKey) {\n-        return true;\n       }\n     }\n     return false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_407/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:08.221003489 -0500\n@@ -1116,29 +1116,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_666/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:41.710012458 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1116,8 +1112,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_852/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:23.026641261 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1058,66 +1057,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java", 
          "line": 358, 
          "faulty": "typeRegistry.setTemplateTypeNames(classTemplateTypeNames);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:01:10.906036203 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_111/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\t2018-12-01 09:09:21.032056501 -0500\n@@ -355,7 +355,6 @@\n             builder.add(typeRegistry.createTemplateType(typeParameter));\n           }\n           classTemplateTypeNames = builder.build();\n-          typeRegistry.setTemplateTypeNames(classTemplateTypeNames);\n         }\n       }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_111/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:21.036056525 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2143/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:57.210285029 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1048/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:05.451205121 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1941/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:26:11.065732584 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1941/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:11.065732584 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1628/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:14.252696822 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_743/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:21.398269099 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1679/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:23:47.428906173 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1679/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:47.428906173 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1146,7 +1143,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2115/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:41.454205293 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_651/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:33.085954667 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2362/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:59.682902341 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2836/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:32.736482867 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1059,9 +1058,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_926/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:02.118863493 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1236/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:19:43.187697762 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1236/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:43.187697762 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1818/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:05.125367098 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_146/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:41.836176983 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_146/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:41.836176983 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1476/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:21:56.520323341 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1476/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:56.520323341 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1649/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:23:30.076797732 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1649/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:30.076797732 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1005/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:43.119086993 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2620/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:32.435828974 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2047/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:05.890022618 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2146/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:27:59.122294658 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2146/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:59.126294679 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1124,21 +1123,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1168,7 +1152,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1945/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:13.001743022 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_881/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:38.722731653 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1338/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:20:38.271961478 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1338/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:38.271961478 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1145,12 +1141,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2854/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:34:41.416528288 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2854/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:41.416528288 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1740/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:20.353106092 -0500\n@@ -1146,10 +1146,8 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_521/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:15.693453586 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,29 +1113,12 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1422/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:28.492195218 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2498/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:31:25.935442195 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2498/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:25.935442195 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1356,7 +1353,7 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n+        return null;\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2872/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:50.908577732 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_802/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:54.754474141 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1637/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:24.180760365 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1079,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2137/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:54.158269638 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1143,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1008/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:45.007097074 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2781/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:59.884309058 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1377/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:58.540056505 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1151/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:18:58.971479330 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1151/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:58.975479350 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1046,10 +1045,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1054,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1108,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2117/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:42.626211248 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1920/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:25:59.205668306 -0500\n@@ -106,7 +106,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1920/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:59.205668306 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1116,8 +1113,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2419/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:42.487176444 -0500\n@@ -1126,10 +1126,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1332/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:20:35.411947987 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1332/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:35.411947987 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2413/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:30:39.635158582 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1145,12 +1141,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2242/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:55.362573800 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2154/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:03.070314510 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1126,10 +1074,6 @@\n       Map<TemplateType, JSType> resolvedTypes) {\n     while (declParams.hasNext() && callParams.hasNext()) {\n       Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n       if (declParam.isVarArgs()) {\n         while (callParams.hasNext()) {\n           maybeResolveTemplatedType(\n@@ -1144,14 +1088,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_7/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:02.123613977 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2240/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:54.410569136 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1116,8 +1115,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1872/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:34.681533442 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1304,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2733/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:33:33.340166220 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n@@ -114,7 +113,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2733/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:33.340166220 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_568/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:13:41.157611882 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_568/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:41.161611906 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1144,14 +1143,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1176/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:11.499541900 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2814/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:19.676414141 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1904/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:51.373625529 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_398/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:03.452969771 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_845/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:19.166618778 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_812/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:01.426514104 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1356,7 +1338,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_617/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:14:14.085824560 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_617/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:14.089824588 -0500\n@@ -1039,17 +1039,9 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,33 +1116,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2475/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:31:14.359372503 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1149,7 +1146,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_381/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:54.536905967 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_574/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:44.041629459 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1059,9 +1055,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1080/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:21.955290951 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1144,14 +1141,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_606/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:08.325784327 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1470/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:53.452309390 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1143/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:55.131460036 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1773/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:42.937239202 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_298/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:04.688627115 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1585/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:51.956572628 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1144,14 +1092,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_615/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:13.125817881 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2684/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:33:07.400024313 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2684/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:07.400024313 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1738/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:19.405100436 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1149,7 +1131,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_999/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:40.099070833 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2618/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:31.491823629 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2069/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:16.438077210 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1922/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:00.169673552 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1718/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:09.785042712 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1418/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:26.564186347 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1788/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:24:50.673284105 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n@@ -114,7 +113,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1788/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:50.677284128 -0500\n@@ -1058,66 +1058,12 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1424/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:21:29.452199632 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,33 +1121,12 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1363/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:51.868025332 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_499/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:13:02.133366886 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_499/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:13:02.137366912 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_613/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:12.145811051 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2567/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:32:03.187661533 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2567/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:03.191661557 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1062,54 +1061,8 @@\n       // @param {T}\n       resolvedTemplateType(\n           resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1099,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2761/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:48.728249303 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 109, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_95/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:09:12.040003358 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n@@ -106,7 +105,6 @@\n     JSType beforeReturn = type.getReturnType();\n     JSType afterReturn = beforeReturn.visit(this);\n     if (beforeReturn != afterReturn) {\n-      changed = true;\n     }\n \n     FunctionParamBuilder paramBuilder = new FunctionParamBuilder(registry);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_95/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:12.044003381 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1144,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1981/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:31.609842578 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2272/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:10.610648240 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1483/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:00.704342338 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2792/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:05.600339527 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n@@ -1168,7 +1167,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1786/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:49.717278575 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1124,21 +1120,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1834/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:25:14.077417948 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1152, 
          "faulty": "map.put(template,join);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2148/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:00.106299610 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1149,7 +1100,6 @@\n         map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n       }\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/JSType.java", 
          "line": 621, 
          "faulty": "return this == that;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:01:11.054036822 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2315/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/JSType.java\t2018-12-01 09:29:33.514759177 -0500\n@@ -618,7 +618,6 @@\n     }\n \n     if (isTemplateType() && that.isTemplateType()) {\n-      return this == that;\n     }\n \n     // Unbox other proxies.\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2315/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:29:33.514759177 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1277/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:05.527805743 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_34/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:08:21.155689101 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_937/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:07.982896025 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 117, 
          "faulty": "changed=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1687/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:23:52.288936151 -0500\n@@ -114,7 +114,6 @@\n       JSType beforeParamType = paramNode.getJSType();\n       JSType afterParamType = beforeParamType.visit(this);\n       if (beforeParamType != afterParamType) {\n-        changed = true;\n       }\n       if (paramNode.isOptionalArg()) {\n         paramBuilder.addOptionalParams(afterParamType);\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1687/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:52.292936176 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2604/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:23.187776451 -0500\n@@ -1145,12 +1145,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n@@ -1168,7 +1162,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_986/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:32.151028081 -0500\n@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_475/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:12:43.365243912 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_475/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:43.365243912 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1069/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:18:16.151260904 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1144,14 +1143,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1734/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:24:17.497089035 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1734/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:24:17.501089058 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_930/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:04.038874167 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1042, 
          "faulty": "maybeResolveTemplatedType(fnType.getTypeOfThis(),getJSType(obj),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1119, 
          "faulty": "maybeResolveTemplateTypeFromNodes(declParams.iterator(),callParams.iterator(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1228/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:39.379679204 -0500\n@@ -1039,10 +1039,6 @@\n     Node callTarget = call.getFirstChild();\n     if (NodeUtil.isGet(callTarget)) {\n       Node obj = callTarget.getFirstChild();\n-      maybeResolveTemplatedType(\n-          fnType.getTypeOfThis(),\n-          getJSType(obj),\n-          resolvedTypes);\n     }\n \n     if (call.hasMoreThanOneChild()) {\n@@ -1116,8 +1112,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1065, 
          "faulty": "if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 94, 
          "faulty": "for (TemplateType visitedType : visitedTypes) {\n  if (visitedType == type) {\n    return true;\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_705/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:15:01.702143578 -0500\n@@ -91,11 +91,6 @@\n    * traversal of a JSType.\n    */\n   private boolean hasVisitedType(TemplateType type) {\n-    for (TemplateType visitedType : visitedTypes) {\n-      if (visitedType == type) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_705/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:15:01.706143605 -0500\n@@ -1059,57 +1059,8 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+\t\t;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1307,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1491/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:04.580359909 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1058,58 +1054,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2067/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:27:15.482072277 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n@@ -1168,7 +1167,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_302/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:11:06.596636994 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1144,14 +1143,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_172/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:09:55.752255754 -0500\n@@ -1046,10 +1046,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2844/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:36.548502839 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1620/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:23:09.368665268 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1620/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:23:09.368665268 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 967, 
          "faulty": "fnType=n.getFirstChild().getJSType().toMaybeFunctionType();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1049, 
          "faulty": "maybeResolveTemplateTypeFromNodes(fnType.getParameters(),call.getChildAtIndex(1).siblings(),resolvedTypes);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1330/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:20:34.431943360 -0500\n@@ -964,7 +964,6 @@\n   private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n     boolean updatedFnType = inferTemplatedTypesForCall(n, fnType);\n     if (updatedFnType) {\n-      fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n     updateBind(n);\n@@ -1046,10 +1045,6 @@\n     }\n \n     if (call.hasMoreThanOneChild()) {\n-      maybeResolveTemplateTypeFromNodes(\n-          fnType.getParameters(),\n-          call.getChildAtIndex(1).siblings(),\n-          resolvedTypes);\n     }\n     return resolvedTypes;\n   }\n@@ -1144,14 +1139,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1022/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:51.719132766 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1124,21 +1121,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_644/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:14:29.153928061 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n@@ -1130,14 +1127,6 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java", 
          "line": 99, 
          "faulty": "return false;", 
          "type": "Replace", 
          "seed": "return true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/jstype/ModificationVisitor.java", 
          "line": 95, 
          "faulty": "return type;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2771/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\t2018-12-01 09:33:54.756281639 -0500\n@@ -92,7 +92,6 @@\n \n     // TODO(johnlenz): remove this simplifying assumption...\n     if (!type.isOrdinaryFunction()) {\n-      return type;\n     }\n \n     boolean changed = false;\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:01:11.058036838 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2771/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/rhino/jstype/TemplateTypeMapReplacer.java\t2018-12-01 09:33:54.756281639 -0500\n@@ -96,6 +96,6 @@\n         return true;\n       }\n     }\n-    return false;\n+    return true;\n   }\n }\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2771/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:54.756281639 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1063, 
          "faulty": "resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_962/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:17:20.534965007 -0500\n@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1148, 
          "faulty": "if (previous == null) {\n  map.put(template,resolved);\n}\n else {\n  JSType join=previous.getLeastSupertype(resolved);\n  map.put(template,join);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_883/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:39.786737723 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1145,12 +1093,6 @@\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1129, 
          "faulty": "maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2198/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:28:33.266465030 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1241/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:19:46.091711884 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n@@ -1146,7 +1131,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_919/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:16:58.262841991 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1133, 
          "faulty": "if (declParam.isVarArgs()) {\n  while (callParams.hasNext()) {\n    maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_1576/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:22:47.104551007 -0500\n@@ -1130,28 +1130,12 @@\n           getJSType(declParam),\n           getJSType(callParams.next()),\n           resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n     }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2757/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:33:46.724238527 -0500\n@@ -1144,14 +1144,6 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeValidator.java", 
          "line": 688, 
          "faulty": "registerIfMismatch(paramItA.next().getJSType(),paramItB.next().getJSType(),error);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1359, 
          "faulty": "propertyType=propertyType.visit(replacer);", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1171, 
          "faulty": "madeChanges=true;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:01:11.050036805 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2827/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeValidator.java\t2018-12-01 09:34:27.744456653 -0500\n@@ -685,8 +685,6 @@\n       Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n       Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n       while (paramItA.hasNext() && paramItB.hasNext()) {\n-        registerIfMismatch(paramItA.next().getJSType(),\n-            paramItB.next().getJSType(), error);\n       }\n \n       registerIfMismatch(\n\n\n--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2827/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:34:27.748456674 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1146,7 +1094,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n@@ -1168,7 +1115,6 @@\n \n     @Override\n     public JSType caseTemplateType(TemplateType type) {\n-      madeChanges = true;\n       JSType replacement = replacements.get(type);\n       return replacement != null ?\n           replacement : registry.getNativeType(UNKNOWN_TYPE);\n@@ -1356,7 +1302,6 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1147, 
          "faulty": "if (!resolved.isUnknownType()) {\n  if (previous == null) {\n    map.put(template,resolved);\n  }\n else {\n    JSType join=previous.getLeastSupertype(resolved);\n    map.put(template,join);\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_415/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:12:12.049030364 -0500\n@@ -1124,34 +1124,11 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n-      if (previous == null) {\n-        map.put(template, resolved);\n-      } else {\n-        JSType join = previous.getLeastSupertype(resolved);\n-        map.put(template, join);\n-      }\n-    }\n   }\n \n   private static class TemplateTypeReplacer extends ModificationVisitor {\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2669/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:32:59.423980181 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_249/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:38.176487739 -0500\n@@ -1124,21 +1124,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1149, 
          "faulty": "map.put(template,resolved);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_218/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:10:21.472397787 -0500\n@@ -1146,7 +1146,6 @@\n     JSType previous = map.get(template);\n     if (!resolved.isUnknownType()) {\n       if (previous == null) {\n-        map.put(template, resolved);\n       } else {\n         JSType join = previous.getLeastSupertype(resolved);\n         map.put(template, join);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1061, 
          "faulty": "if (paramType.isTemplateType()) {\n  resolvedTemplateType(resolvedTypes,paramType.toMaybeTemplateType(),argType);\n}\n else if (paramType.isUnionType()) {\n  UnionType unionType=paramType.toMaybeUnionType();\n  for (  JSType alernative : unionType.getAlternates()) {\n    maybeResolveTemplatedType(alernative,argType,resolvedTypes);\n  }\n}\n else if (paramType.isFunctionType()) {\n  FunctionType paramFunctionType=paramType.toMaybeFunctionType();\n  FunctionType argFunctionType=argType.restrictByNotNullOrUndefined().collapseUnion().toMaybeFunctionType();\n  if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n    maybeResolveTemplatedType(paramFunctionType.getTypeOfThis(),argFunctionType.getTypeOfThis(),resolvedTypes);\n    maybeResolveTemplatedType(paramFunctionType.getReturnType(),argFunctionType.getReturnType(),resolvedTypes);\n    maybeResolveTemplateTypeFromNodes(paramFunctionType.getParameters(),argFunctionType.getParameters(),resolvedTypes);\n  }\n}\n else if (paramType.isTemplatizedType()) {\n  ObjectType referencedParamType=paramType.toMaybeTemplatizedType().getReferencedType();\n  JSType argObjectType=argType.restrictByNotNullOrUndefined().collapseUnion();\n  if (argObjectType.isSubtype(referencedParamType)) {\n    TemplateTypeMap paramTypeMap=paramType.getTemplateTypeMap();\n    TemplateTypeMap argTypeMap=argObjectType.getTemplateTypeMap();\n    for (    TemplateType key : paramTypeMap.getTemplateKeys()) {\n      maybeResolveTemplatedType(paramTypeMap.getTemplateType(key),argTypeMap.getTemplateType(key),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/TypeInference.java", 
          "line": 1127, 
          "faulty": "while (declParams.hasNext() && callParams.hasNext()) {\n  Node declParam=declParams.next();\n  maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n  if (declParam.isVarArgs()) {\n    while (callParams.hasNext()) {\n      maybeResolveTemplatedType(getJSType(declParam),getJSType(callParams.next()),resolvedTypes);\n    }\n  }\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:01:13.654047680 -0500\n+++ /tmp/Arja_Defects4J_Closure_112/patches_famj/Patch_2031/patched/tmp/Arja_Defects4J_Closure_112/src/com/google/javascript/jscomp/TypeInference.java\t2018-12-01 09:26:56.901975811 -0500\n@@ -1058,58 +1058,6 @@\n       JSType paramType,\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n-    } else if (paramType.isUnionType()) {\n-      // @param {Array.<T>|NodeList|Arguments|{length:number}}\n-      UnionType unionType = paramType.toMaybeUnionType();\n-      for (JSType alernative : unionType.getAlternates()) {\n-        maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n-      }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1124,21 +1072,6 @@\n       Iterator<Node> declParams,\n       Iterator<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    while (declParams.hasNext() && callParams.hasNext()) {\n-      Node declParam = declParams.next();\n-      maybeResolveTemplatedType(\n-          getJSType(declParam),\n-          getJSType(callParams.next()),\n-          resolvedTypes);\n-      if (declParam.isVarArgs()) {\n-        while (callParams.hasNext()) {\n-          maybeResolveTemplatedType(\n-              getJSType(declParam),\n-              getJSType(callParams.next()),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n   }\n \n   private static void resolvedTemplateType(\n\n\n"
    }
  ]
}