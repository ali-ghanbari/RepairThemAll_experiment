{
  "repair_end": "2018-12-02 11:33:35.282589", 
  "repair_begin": "2018-12-02 11:18:37.403939", 
  "patches": [
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_361/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:29:20.024592516 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        final String PARAM_NAME = \"jscomp_throw_param\";\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_413/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:30:01.284333021 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      StringBuilder builder = new StringBuilder();\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "return null;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:18:15.446650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_689/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:33:32.219066662 -0500\n@@ -1443,7 +1443,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_505/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:31:12.387895086 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_588/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:32:15.563513810 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      final String PARAM_NAME = \"jscomp_throw_param\";\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "Delete", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-02 05:18:15.422650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_686/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-02 05:33:30.407076528 -0500\n@@ -987,7 +987,7 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            ;\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_686/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:33:30.407076528 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        StringBuilder builder = new StringBuilder();\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_358/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:29:18.344603179 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      int start = 0;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_95/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:25:51.513997421 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_54/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:25:17.442248430 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_89/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:25:47.402027300 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        int start = 0;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "return null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 208, 
          "faulty": "Var aliasVar=scope.getVar(aliasParent.getString());", 
          "type": "InsertBefore", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_112/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:26:03.009914450 -0500\n@@ -205,7 +205,8 @@\n     if (aliasParent.isName()) {\n       // Ensure that the local variable is well defined and never reassigned.\n       Scope scope = alias.scope;\n-      Var aliasVar = scope.getVar(aliasParent.getString());\n+      int index = -1;\n+\tVar aliasVar = scope.getVar(aliasParent.getString());\n       ReferenceCollectingCallback collector =\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:18:15.446650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_112/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:26:03.013914422 -0500\n@@ -1443,7 +1443,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return this;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-02 05:18:15.422650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_531/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-02 05:31:31.403779636 -0500\n@@ -309,7 +309,8 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n+        JSType type = n.getJSType();\n+\t\treturn;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_531/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:31:31.403779636 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return getString().isEmpty() ? false : true;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return new DotFormatter();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:18:15.446650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_241/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:27:45.165208763 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_241/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:27:45.165208763 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_255/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:27:54.449147028 -0500\n@@ -473,9 +473,7 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n+      int index = -1;\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "InsertBefore", 
          "seed": "formatConclusion();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_590/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:32:16.519508088 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "InsertBefore", 
          "seed": "JSType type=n.getJSType();"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return new DefaultCodingConvention();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_304/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:28:34.436884858 -0500\n@@ -219,15 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-02 05:18:15.422650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_304/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-02 05:28:34.436884858 -0500\n@@ -196,7 +196,8 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n+        JSType type = n.getJSType();\n+\t\treturn false;\n       }\n \n       Node current;\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_304/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:28:34.436884858 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_173/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:26:52.493566077 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        StringBuilder builder = new StringBuilder();\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_406/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:29:56.512362812 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        int index = -1;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "int start=0;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_102/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:25:56.545961001 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "int start=0;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 184, 
          "faulty": "return \"RETURN\";", 
          "type": "Replace", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase CAST:\nreturn \"CAST\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\ncase LB:\nreturn \"LB\";\ncase LC:\nreturn \"LC\";\ncase COLON:\nreturn \"COLON\";\n}"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_155/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:26:36.965673953 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      int start = 0;\n     }\n \n     return false;\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-02 05:18:15.446650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_155/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-02 05:26:36.969673925 -0500\n@@ -181,7 +181,210 @@\n   public static String name(int token) {\n         switch (token) {\n           case ERROR:           return \"ERROR\";\n-          case RETURN:          return \"RETURN\";\n+          case RETURN:          switch (token) {\n+\t\t\tcase ERROR:\n+\t\t\t\treturn \"ERROR\";\n+\t\t\tcase RETURN:\n+\t\t\t\treturn \"RETURN\";\n+\t\t\tcase BITOR:\n+\t\t\t\treturn \"BITOR\";\n+\t\t\tcase BITXOR:\n+\t\t\t\treturn \"BITXOR\";\n+\t\t\tcase BITAND:\n+\t\t\t\treturn \"BITAND\";\n+\t\t\tcase EQ:\n+\t\t\t\treturn \"EQ\";\n+\t\t\tcase NE:\n+\t\t\t\treturn \"NE\";\n+\t\t\tcase LT:\n+\t\t\t\treturn \"LT\";\n+\t\t\tcase LE:\n+\t\t\t\treturn \"LE\";\n+\t\t\tcase GT:\n+\t\t\t\treturn \"GT\";\n+\t\t\tcase GE:\n+\t\t\t\treturn \"GE\";\n+\t\t\tcase LSH:\n+\t\t\t\treturn \"LSH\";\n+\t\t\tcase RSH:\n+\t\t\t\treturn \"RSH\";\n+\t\t\tcase URSH:\n+\t\t\t\treturn \"URSH\";\n+\t\t\tcase ADD:\n+\t\t\t\treturn \"ADD\";\n+\t\t\tcase SUB:\n+\t\t\t\treturn \"SUB\";\n+\t\t\tcase MUL:\n+\t\t\t\treturn \"MUL\";\n+\t\t\tcase DIV:\n+\t\t\t\treturn \"DIV\";\n+\t\t\tcase MOD:\n+\t\t\t\treturn \"MOD\";\n+\t\t\tcase NOT:\n+\t\t\t\treturn \"NOT\";\n+\t\t\tcase BITNOT:\n+\t\t\t\treturn \"BITNOT\";\n+\t\t\tcase POS:\n+\t\t\t\treturn \"POS\";\n+\t\t\tcase NEG:\n+\t\t\t\treturn \"NEG\";\n+\t\t\tcase NEW:\n+\t\t\t\treturn \"NEW\";\n+\t\t\tcase DELPROP:\n+\t\t\t\treturn \"DELPROP\";\n+\t\t\tcase TYPEOF:\n+\t\t\t\treturn \"TYPEOF\";\n+\t\t\tcase GETPROP:\n+\t\t\t\treturn \"GETPROP\";\n+\t\t\tcase GETELEM:\n+\t\t\t\treturn \"GETELEM\";\n+\t\t\tcase CALL:\n+\t\t\t\treturn \"CALL\";\n+\t\t\tcase NAME:\n+\t\t\t\treturn \"NAME\";\n+\t\t\tcase LABEL_NAME:\n+\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\tcase NUMBER:\n+\t\t\t\treturn \"NUMBER\";\n+\t\t\tcase STRING:\n+\t\t\t\treturn \"STRING\";\n+\t\t\tcase STRING_KEY:\n+\t\t\t\treturn \"STRING_KEY\";\n+\t\t\tcase NULL:\n+\t\t\t\treturn \"NULL\";\n+\t\t\tcase THIS:\n+\t\t\t\treturn \"THIS\";\n+\t\t\tcase FALSE:\n+\t\t\t\treturn \"FALSE\";\n+\t\t\tcase TRUE:\n+\t\t\t\treturn \"TRUE\";\n+\t\t\tcase SHEQ:\n+\t\t\t\treturn \"SHEQ\";\n+\t\t\tcase SHNE:\n+\t\t\t\treturn \"SHNE\";\n+\t\t\tcase REGEXP:\n+\t\t\t\treturn \"REGEXP\";\n+\t\t\tcase THROW:\n+\t\t\t\treturn \"THROW\";\n+\t\t\tcase IN:\n+\t\t\t\treturn \"IN\";\n+\t\t\tcase INSTANCEOF:\n+\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\tcase ARRAYLIT:\n+\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\tcase OBJECTLIT:\n+\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\tcase TRY:\n+\t\t\t\treturn \"TRY\";\n+\t\t\tcase PARAM_LIST:\n+\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\tcase COMMA:\n+\t\t\t\treturn \"COMMA\";\n+\t\t\tcase ASSIGN:\n+\t\t\t\treturn \"ASSIGN\";\n+\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\tcase ASSIGN_LSH:\n+\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\tcase ASSIGN_RSH:\n+\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\tcase ASSIGN_URSH:\n+\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\tcase ASSIGN_ADD:\n+\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\tcase ASSIGN_SUB:\n+\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\tcase ASSIGN_MUL:\n+\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\tcase ASSIGN_DIV:\n+\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\tcase ASSIGN_MOD:\n+\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\tcase HOOK:\n+\t\t\t\treturn \"HOOK\";\n+\t\t\tcase OR:\n+\t\t\t\treturn \"OR\";\n+\t\t\tcase AND:\n+\t\t\t\treturn \"AND\";\n+\t\t\tcase INC:\n+\t\t\t\treturn \"INC\";\n+\t\t\tcase DEC:\n+\t\t\t\treturn \"DEC\";\n+\t\t\tcase FUNCTION:\n+\t\t\t\treturn \"FUNCTION\";\n+\t\t\tcase IF:\n+\t\t\t\treturn \"IF\";\n+\t\t\tcase SWITCH:\n+\t\t\t\treturn \"SWITCH\";\n+\t\t\tcase CASE:\n+\t\t\t\treturn \"CASE\";\n+\t\t\tcase DEFAULT_CASE:\n+\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\tcase WHILE:\n+\t\t\t\treturn \"WHILE\";\n+\t\t\tcase DO:\n+\t\t\t\treturn \"DO\";\n+\t\t\tcase FOR:\n+\t\t\t\treturn \"FOR\";\n+\t\t\tcase BREAK:\n+\t\t\t\treturn \"BREAK\";\n+\t\t\tcase CONTINUE:\n+\t\t\t\treturn \"CONTINUE\";\n+\t\t\tcase VAR:\n+\t\t\t\treturn \"VAR\";\n+\t\t\tcase WITH:\n+\t\t\t\treturn \"WITH\";\n+\t\t\tcase CATCH:\n+\t\t\t\treturn \"CATCH\";\n+\t\t\tcase EMPTY:\n+\t\t\t\treturn \"EMPTY\";\n+\t\t\tcase BLOCK:\n+\t\t\t\treturn \"BLOCK\";\n+\t\t\tcase LABEL:\n+\t\t\t\treturn \"LABEL\";\n+\t\t\tcase EXPR_RESULT:\n+\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\tcase SCRIPT:\n+\t\t\t\treturn \"SCRIPT\";\n+\t\t\tcase GETTER_DEF:\n+\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\tcase SETTER_DEF:\n+\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\tcase CONST:\n+\t\t\t\treturn \"CONST\";\n+\t\t\tcase DEBUGGER:\n+\t\t\t\treturn \"DEBUGGER\";\n+\t\t\tcase CAST:\n+\t\t\t\treturn \"CAST\";\n+\t\t\tcase ANNOTATION:\n+\t\t\t\treturn \"ANNOTATION\";\n+\t\t\tcase PIPE:\n+\t\t\t\treturn \"PIPE\";\n+\t\t\tcase STAR:\n+\t\t\t\treturn \"STAR\";\n+\t\t\tcase EOC:\n+\t\t\t\treturn \"EOC\";\n+\t\t\tcase QMARK:\n+\t\t\t\treturn \"QMARK\";\n+\t\t\tcase ELLIPSIS:\n+\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\tcase BANG:\n+\t\t\t\treturn \"BANG\";\n+\t\t\tcase VOID:\n+\t\t\t\treturn \"VOID\";\n+\t\t\tcase EQUALS:\n+\t\t\t\treturn \"EQUALS\";\n+\t\t\tcase LB:\n+\t\t\t\treturn \"LB\";\n+\t\t\tcase LC:\n+\t\t\t\treturn \"LC\";\n+\t\t\tcase COLON:\n+\t\t\t\treturn \"COLON\";\n+\t\t\t}\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "int index=-1;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_218/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:27:26.325335137 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      int index = -1;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "parent=null;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "final String PARAM_NAME=\"jscomp_throw_param\";"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:18:15.446650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_132/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-02 05:26:18.533803683 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        parent = null;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_132/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:26:18.533803683 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "StringBuilder builder=new StringBuilder();"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_105/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:25:58.061950060 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "return this;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return 0;"
        }
      ], 
      "patch": "--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:18:18.314650755 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_194/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-02 05:27:07.957459849 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n--- /tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:18:15.434650689 -0500\n+++ /tmp/RSRepair_Defects4J_Closure_130/patches_dfj3/Patch_194/patched/tmp/RSRepair_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-02 05:27:07.957459849 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }
  ]
}