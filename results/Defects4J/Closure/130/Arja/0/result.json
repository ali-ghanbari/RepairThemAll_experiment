{
  "repair_end": "2018-12-01 15:09:30.571605", 
  "repair_begin": "2018-12-01 14:46:02.059990", 
  "patches": [
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1144/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:54.831345614 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_449/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:45.539638540 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_449/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:45.539638540 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1533/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:24.027797257 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1710/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:01.522065784 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1545/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:30.507952510 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1545/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:30.507952510 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "this.type=Type.OTHER;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1358/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:53.561912460 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1358/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:53.565912545 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            ;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1358/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:53.565912545 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Replace", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_808/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:56.223616820 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_808/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:56.223616820 -0500\n@@ -179,7 +179,7 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n   }\n \n   /**\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_808/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:56.223616820 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_376/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:05.950770314 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1770/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:33.454782025 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1770/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:33.454782025 -0500\n@@ -225,7 +225,7 @@\n \n           Node newNode = alias.node.cloneTree();\n           aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n+          return false;\n         }\n \n         // just set the original alias to null.\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_105/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:52.127702061 -0500\n@@ -178,7 +178,7 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              break;\n             }\n           }\n         }\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_37/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:13.734979451 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_776/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:38.623260280 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1495/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:02.819359551 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1495/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:02.819359551 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_371/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:03.830723273 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_371/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:03.830723273 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "return new NodeMismatch(this,node2);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1969/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:09:27.633264220 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1969/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:27.633264220 -0500\n@@ -1443,7 +1443,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return new NodeMismatch(this, node2);\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1969/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:27.637264305 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_295/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:28.785936809 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_295/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:28.789936899 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1388/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:08.318223364 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_574/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:51.141040141 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_574/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:51.145040226 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_574/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:51.145040226 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_260/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:10.165511607 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_260/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:10.165511607 -0500\n@@ -225,7 +225,6 @@\n \n           Node newNode = alias.node.cloneTree();\n           aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n         }\n \n         // just set the original alias to null.\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_653/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:31.933892403 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_653/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:31.933892403 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1269/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:04.452866042 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1269/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:03:04.456866128 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1269/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:04.456866128 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1684/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:49.501793128 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1684/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:49.505793217 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_396/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:17.459024659 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1012/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:46.285813479 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_489/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:56:06.516091352 -0500\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_489/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:06.520091438 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1433, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1392/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:09.758253625 -0500\n@@ -1430,7 +1430,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1392/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:04:09.758253625 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1392/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:09.762253709 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_917/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:54.128778911 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_917/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:54.128778911 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_917/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:54.128778911 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_401/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:20.231085678 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_401/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:20.235085765 -0500\n@@ -988,7 +988,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_401/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:20.235085765 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1748/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:21.338511589 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1748/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:21.342511678 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_579/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:53.413087965 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_579/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:53.413087965 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_529/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:27.668543411 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_529/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:27.672543496 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_829/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:07.723848899 -0500\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_829/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:07.727848980 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1474/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:50.895112476 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_539/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:32.636648963 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_539/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:32.636648963 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1446/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:38.118846846 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_710/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:03.098535194 -0500\n@@ -987,7 +987,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_710/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:03.102535276 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1417, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_647/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:29.133834315 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_647/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:29.137834398 -0500\n@@ -1414,7 +1414,9 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_647/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:29.137834398 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_444/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:43.411592337 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_444/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:43.411592337 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1288/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:15.793109395 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1624/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:13.028954482 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1624/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:13.028954482 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_337/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:49.382401100 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1654/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:30.581360289 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1654/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:30.585360383 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1381/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:04.910151694 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1381/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:04:04.914151777 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1417, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_246/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:03.109349041 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_246/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:03.109349041 -0500\n@@ -1414,7 +1414,9 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1116/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:40.587028203 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 184, 
          "faulty": "return \"RETURN\";", 
          "type": "InsertBefore", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase CAST:\nreturn \"CAST\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\ncase LB:\nreturn \"LB\";\ncase LC:\nreturn \"LC\";\ncase COLON:\nreturn \"COLON\";\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1843/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:08:15.791715411 -0500\n@@ -181,7 +181,213 @@\n   public static String name(int token) {\n         switch (token) {\n           case ERROR:           return \"ERROR\";\n-          case RETURN:          return \"RETURN\";\n+          case RETURN:          {\n+\t\t\t\tswitch (token) {\n+\t\t\t\tcase ERROR:\n+\t\t\t\t\treturn \"ERROR\";\n+\t\t\t\tcase RETURN:\n+\t\t\t\t\treturn \"RETURN\";\n+\t\t\t\tcase BITOR:\n+\t\t\t\t\treturn \"BITOR\";\n+\t\t\t\tcase BITXOR:\n+\t\t\t\t\treturn \"BITXOR\";\n+\t\t\t\tcase BITAND:\n+\t\t\t\t\treturn \"BITAND\";\n+\t\t\t\tcase EQ:\n+\t\t\t\t\treturn \"EQ\";\n+\t\t\t\tcase NE:\n+\t\t\t\t\treturn \"NE\";\n+\t\t\t\tcase LT:\n+\t\t\t\t\treturn \"LT\";\n+\t\t\t\tcase LE:\n+\t\t\t\t\treturn \"LE\";\n+\t\t\t\tcase GT:\n+\t\t\t\t\treturn \"GT\";\n+\t\t\t\tcase GE:\n+\t\t\t\t\treturn \"GE\";\n+\t\t\t\tcase LSH:\n+\t\t\t\t\treturn \"LSH\";\n+\t\t\t\tcase RSH:\n+\t\t\t\t\treturn \"RSH\";\n+\t\t\t\tcase URSH:\n+\t\t\t\t\treturn \"URSH\";\n+\t\t\t\tcase ADD:\n+\t\t\t\t\treturn \"ADD\";\n+\t\t\t\tcase SUB:\n+\t\t\t\t\treturn \"SUB\";\n+\t\t\t\tcase MUL:\n+\t\t\t\t\treturn \"MUL\";\n+\t\t\t\tcase DIV:\n+\t\t\t\t\treturn \"DIV\";\n+\t\t\t\tcase MOD:\n+\t\t\t\t\treturn \"MOD\";\n+\t\t\t\tcase NOT:\n+\t\t\t\t\treturn \"NOT\";\n+\t\t\t\tcase BITNOT:\n+\t\t\t\t\treturn \"BITNOT\";\n+\t\t\t\tcase POS:\n+\t\t\t\t\treturn \"POS\";\n+\t\t\t\tcase NEG:\n+\t\t\t\t\treturn \"NEG\";\n+\t\t\t\tcase NEW:\n+\t\t\t\t\treturn \"NEW\";\n+\t\t\t\tcase DELPROP:\n+\t\t\t\t\treturn \"DELPROP\";\n+\t\t\t\tcase TYPEOF:\n+\t\t\t\t\treturn \"TYPEOF\";\n+\t\t\t\tcase GETPROP:\n+\t\t\t\t\treturn \"GETPROP\";\n+\t\t\t\tcase GETELEM:\n+\t\t\t\t\treturn \"GETELEM\";\n+\t\t\t\tcase CALL:\n+\t\t\t\t\treturn \"CALL\";\n+\t\t\t\tcase NAME:\n+\t\t\t\t\treturn \"NAME\";\n+\t\t\t\tcase LABEL_NAME:\n+\t\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\t\tcase NUMBER:\n+\t\t\t\t\treturn \"NUMBER\";\n+\t\t\t\tcase STRING:\n+\t\t\t\t\treturn \"STRING\";\n+\t\t\t\tcase STRING_KEY:\n+\t\t\t\t\treturn \"STRING_KEY\";\n+\t\t\t\tcase NULL:\n+\t\t\t\t\treturn \"NULL\";\n+\t\t\t\tcase THIS:\n+\t\t\t\t\treturn \"THIS\";\n+\t\t\t\tcase FALSE:\n+\t\t\t\t\treturn \"FALSE\";\n+\t\t\t\tcase TRUE:\n+\t\t\t\t\treturn \"TRUE\";\n+\t\t\t\tcase SHEQ:\n+\t\t\t\t\treturn \"SHEQ\";\n+\t\t\t\tcase SHNE:\n+\t\t\t\t\treturn \"SHNE\";\n+\t\t\t\tcase REGEXP:\n+\t\t\t\t\treturn \"REGEXP\";\n+\t\t\t\tcase THROW:\n+\t\t\t\t\treturn \"THROW\";\n+\t\t\t\tcase IN:\n+\t\t\t\t\treturn \"IN\";\n+\t\t\t\tcase INSTANCEOF:\n+\t\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\t\tcase ARRAYLIT:\n+\t\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\t\tcase OBJECTLIT:\n+\t\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\t\tcase TRY:\n+\t\t\t\t\treturn \"TRY\";\n+\t\t\t\tcase PARAM_LIST:\n+\t\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\t\tcase COMMA:\n+\t\t\t\t\treturn \"COMMA\";\n+\t\t\t\tcase ASSIGN:\n+\t\t\t\t\treturn \"ASSIGN\";\n+\t\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\t\tcase ASSIGN_LSH:\n+\t\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\t\tcase ASSIGN_RSH:\n+\t\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\t\tcase ASSIGN_URSH:\n+\t\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\t\tcase ASSIGN_ADD:\n+\t\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\t\tcase ASSIGN_SUB:\n+\t\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\t\tcase ASSIGN_MUL:\n+\t\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\t\tcase ASSIGN_DIV:\n+\t\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\t\tcase ASSIGN_MOD:\n+\t\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\t\tcase HOOK:\n+\t\t\t\t\treturn \"HOOK\";\n+\t\t\t\tcase OR:\n+\t\t\t\t\treturn \"OR\";\n+\t\t\t\tcase AND:\n+\t\t\t\t\treturn \"AND\";\n+\t\t\t\tcase INC:\n+\t\t\t\t\treturn \"INC\";\n+\t\t\t\tcase DEC:\n+\t\t\t\t\treturn \"DEC\";\n+\t\t\t\tcase FUNCTION:\n+\t\t\t\t\treturn \"FUNCTION\";\n+\t\t\t\tcase IF:\n+\t\t\t\t\treturn \"IF\";\n+\t\t\t\tcase SWITCH:\n+\t\t\t\t\treturn \"SWITCH\";\n+\t\t\t\tcase CASE:\n+\t\t\t\t\treturn \"CASE\";\n+\t\t\t\tcase DEFAULT_CASE:\n+\t\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\t\tcase WHILE:\n+\t\t\t\t\treturn \"WHILE\";\n+\t\t\t\tcase DO:\n+\t\t\t\t\treturn \"DO\";\n+\t\t\t\tcase FOR:\n+\t\t\t\t\treturn \"FOR\";\n+\t\t\t\tcase BREAK:\n+\t\t\t\t\treturn \"BREAK\";\n+\t\t\t\tcase CONTINUE:\n+\t\t\t\t\treturn \"CONTINUE\";\n+\t\t\t\tcase VAR:\n+\t\t\t\t\treturn \"VAR\";\n+\t\t\t\tcase WITH:\n+\t\t\t\t\treturn \"WITH\";\n+\t\t\t\tcase CATCH:\n+\t\t\t\t\treturn \"CATCH\";\n+\t\t\t\tcase EMPTY:\n+\t\t\t\t\treturn \"EMPTY\";\n+\t\t\t\tcase BLOCK:\n+\t\t\t\t\treturn \"BLOCK\";\n+\t\t\t\tcase LABEL:\n+\t\t\t\t\treturn \"LABEL\";\n+\t\t\t\tcase EXPR_RESULT:\n+\t\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\t\tcase SCRIPT:\n+\t\t\t\t\treturn \"SCRIPT\";\n+\t\t\t\tcase GETTER_DEF:\n+\t\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\t\tcase SETTER_DEF:\n+\t\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\t\tcase CONST:\n+\t\t\t\t\treturn \"CONST\";\n+\t\t\t\tcase DEBUGGER:\n+\t\t\t\t\treturn \"DEBUGGER\";\n+\t\t\t\tcase CAST:\n+\t\t\t\t\treturn \"CAST\";\n+\t\t\t\tcase ANNOTATION:\n+\t\t\t\t\treturn \"ANNOTATION\";\n+\t\t\t\tcase PIPE:\n+\t\t\t\t\treturn \"PIPE\";\n+\t\t\t\tcase STAR:\n+\t\t\t\t\treturn \"STAR\";\n+\t\t\t\tcase EOC:\n+\t\t\t\t\treturn \"EOC\";\n+\t\t\t\tcase QMARK:\n+\t\t\t\t\treturn \"QMARK\";\n+\t\t\t\tcase ELLIPSIS:\n+\t\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\t\tcase BANG:\n+\t\t\t\t\treturn \"BANG\";\n+\t\t\t\tcase VOID:\n+\t\t\t\t\treturn \"VOID\";\n+\t\t\t\tcase EQUALS:\n+\t\t\t\t\treturn \"EQUALS\";\n+\t\t\t\tcase LB:\n+\t\t\t\t\treturn \"LB\";\n+\t\t\t\tcase LC:\n+\t\t\t\t\treturn \"LC\";\n+\t\t\t\tcase COLON:\n+\t\t\t\t\treturn \"COLON\";\n+\t\t\t\t}\n+\t\t\t\treturn \"RETURN\";\n+\t\t\t}\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1843/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:15.791715411 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1843/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:15.791715411 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case ADD:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_55/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:52:25.083193235 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_55/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:25.083193235 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_55/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:25.083193235 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_55/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:25.087193310 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_684/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:49.730260280 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_684/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:49.734260362 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1274/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:07.276926747 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1071/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:15.526463767 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1071/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:01:15.526463767 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1071/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:15.530463857 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_227/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:53.849134441 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_227/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:53.849134441 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_227/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:53.853134534 -0500\n@@ -235,7 +235,6 @@\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1563/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:38.912152816 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_890/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:38.512467035 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1942/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:09:13.428961057 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1942/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:13.432961142 -0500\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Delete", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_592/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:59.213209852 -0500\n@@ -178,7 +178,6 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n             }\n           }\n         }\n@@ -213,30 +212,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_171/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:26.416489855 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_171/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:26.416489855 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_171/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:26.420489950 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1300/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:22.209246606 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1300/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:22.213246692 -0500\n@@ -177,9 +177,11 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1440/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:35.342789000 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1028/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:54.241977864 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1028/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:54.241977864 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1028/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:54.245977955 -0500\n@@ -219,15 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_99/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:48.619636108 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_99/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:48.619636108 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1539/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:26.911866439 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1120/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:42.031060492 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1329/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:38.417591764 -0500\n@@ -987,7 +987,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1329/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:38.417591764 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_499/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:11.528198867 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_499/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:11.528198867 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_465/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:52.631792162 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_435/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:37.735468850 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1833/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:09.979588274 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1833/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:08:09.983588362 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1833/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:09.983588362 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_331/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:46.510336720 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_331/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:46.510336720 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1170/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:08.171640783 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1335/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:41.265652205 -0500\n@@ -987,7 +987,10 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tthis.type = Type.OTHER;\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1335/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:41.269652290 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1692/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:53.701888597 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1692/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:53.705888690 -0500\n@@ -219,15 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n@@ -235,7 +226,7 @@\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n+        return false;\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_693/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:54.682362257 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_693/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:54.686362339 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_693/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:54.686362339 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case BLOCK:"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_341/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:54:50.858434142 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_341/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:50.862434232 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1014/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:46.973827060 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1638/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:06:21.461149964 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1638/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:21.465150056 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_837/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:12.075936551 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_837/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:12.075936551 -0500\n@@ -1443,7 +1443,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_837/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:12.075936551 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1390/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:09.030238329 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1723/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:08.126214856 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1723/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:08.130214945 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1723/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:08.130214945 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Delete", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1485/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:57.255244359 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1485/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:57.259244442 -0500\n@@ -178,7 +178,6 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n             }\n           }\n         }\n@@ -228,8 +227,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_359/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:58.130596504 -0500\n@@ -987,7 +987,7 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            ;\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_359/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:58.130596504 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1739/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:17.146417652 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1739/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:17.146417652 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1739/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:17.150417741 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1338/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:03:42.693682488 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1338/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:42.693682488 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1338/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:42.697682572 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_78/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:38.395443809 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_78/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:38.395443809 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_537/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:31.924633851 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_537/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:31.924633851 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1737/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:16.418401318 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1737/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:07:16.422401408 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1737/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:16.422401408 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1125/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:44.203109009 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1125/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:01:44.207109097 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1652/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:29.877344096 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1620/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:10.904905081 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1620/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:06:10.908905174 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1620/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:10.908905174 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1001/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:40.705703274 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1001/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:40.705703274 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_630/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:20.573656369 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_630/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:20.577656451 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Replace", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1811/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:57.279309389 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1362/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:55.717957982 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1376/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:02.118092917 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1376/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:02.118092917 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_719/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:08.054636817 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_719/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:08.054636817 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_316/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:37.958144326 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_316/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:37.958144326 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1443/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:36.726817845 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_644/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:27.725805083 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1917/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:59.872670399 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1917/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:59.876670485 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1421/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:24.874570447 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_153/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:18.484300859 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_153/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:18.488300954 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_153/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:18.488300954 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1570/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:42.484237600 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1570/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:42.484237600 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_200/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:39.352795520 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_200/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:39.352795520 -0500\n@@ -987,7 +987,7 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            ;\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_200/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:39.352795520 -0500\n@@ -178,7 +178,10 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\tname.removeRef(ref);\n             }\n           }\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_634/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:22.021686509 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_634/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:22.021686509 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_110/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:52:55.123758377 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_110/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:55.123758377 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1004/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:42.089730618 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1784/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:41.154953094 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1784/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:07:41.154953094 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1784/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:41.158953183 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_700/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:57.502420255 -0500\n@@ -178,7 +178,9 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t}\n             }\n           }\n         }\n@@ -213,30 +215,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_272/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:16.233650769 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_272/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:16.233650769 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1305/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:24.997306126 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1305/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:25.001306212 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1305/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:03:25.001306212 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1158/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:02.643518705 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1158/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:02.647518794 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_604/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:05.657344943 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_759/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:29.383072406 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_759/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:29.383072406 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_721/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:08.758651240 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1525/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:20.491724316 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_934/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:02.028936294 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_934/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:02.028936294 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_594/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:59.921224711 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_594/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:59.925224796 -0500\n@@ -235,7 +235,7 @@\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n+        return false;\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_339/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:54:50.158418476 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"SUB\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_339/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:50.158418476 -0500\n@@ -987,7 +987,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_339/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:50.158418476 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_301/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:31.602000653 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_301/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:31.606000742 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_92/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:45.635579996 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_92/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:45.635579996 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_124/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:02.355912708 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_248/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:03.905367421 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_248/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:03.905367421 -0500\n@@ -988,7 +988,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_59/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:27.499238728 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_59/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:52:27.499238728 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_59/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:27.499238728 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_786/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:44.271374883 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_786/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:44.275374964 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1789/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:44.007016303 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1600/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:58.684619584 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1600/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:58.684619584 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            ;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1600/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:58.688619677 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_291/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:26.577886665 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_291/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:26.581886757 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_561/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:43.968888885 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case ADD:"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_414/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:55:26.743228653 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_414/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:55:26.743228653 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_414/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:26.747228741 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_511/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:17.824333570 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_511/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:17.824333570 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1826/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:08:05.715494805 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1826/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:05.715494805 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1385/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:06.934194267 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1020/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:49.829883418 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_811/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:57.795648585 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_811/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:58:57.795648585 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SUB\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_632/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:21.281671107 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_632/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:21.281671107 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1527/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:21.179738485 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_158/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:20.624351971 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_158/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:20.624351971 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_158/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:20.628352066 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case BLOCK:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_657/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:57:34.105937422 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_657/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:34.105937422 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_657/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:34.109937505 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1406/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:16.962404803 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1406/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:16.962404803 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_310/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:35.770094934 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_995/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:37.805645957 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_995/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:37.809646036 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1340/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:43.397697410 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1340/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:43.401697495 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_183/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:32.136625400 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_855/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:21.360123227 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1307/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:25.697321060 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1307/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:25.697321060 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_551/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:39.040784691 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_216/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:48.877018613 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_216/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:48.881018706 -0500\n@@ -178,7 +178,6 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n             }\n           }\n         }\n@@ -213,30 +212,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1017/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:48.429855795 -0500\n@@ -989,7 +989,10 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            {\n+\t\t\t\tthis.type = Type.OTHER;\n+\t\t\t\tbreak;\n+\t\t\t}\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1017/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:48.429855795 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_97/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:47.895622495 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_97/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:52:47.895622495 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1461/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:44.482979282 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1461/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:44.486979365 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "InsertBefore", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1022/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:50.537897385 -0500\n@@ -988,7 +988,10 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            {\n+\t\t\t\tthis.type = Type.OTHER;\n+\t\t\t\ttotalGets--;\n+\t\t\t}\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1022/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:50.537897385 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 184, 
          "faulty": "return \"RETURN\";", 
          "type": "InsertBefore", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase CAST:\nreturn \"CAST\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\ncase LB:\nreturn \"LB\";\ncase LC:\nreturn \"LC\";\ncase COLON:\nreturn \"COLON\";\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1882/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:08:39.140223204 -0500\n@@ -181,7 +181,213 @@\n   public static String name(int token) {\n         switch (token) {\n           case ERROR:           return \"ERROR\";\n-          case RETURN:          return \"RETURN\";\n+          case RETURN:          {\n+\t\t\t\tswitch (token) {\n+\t\t\t\tcase ERROR:\n+\t\t\t\t\treturn \"ERROR\";\n+\t\t\t\tcase RETURN:\n+\t\t\t\t\treturn \"RETURN\";\n+\t\t\t\tcase BITOR:\n+\t\t\t\t\treturn \"BITOR\";\n+\t\t\t\tcase BITXOR:\n+\t\t\t\t\treturn \"BITXOR\";\n+\t\t\t\tcase BITAND:\n+\t\t\t\t\treturn \"BITAND\";\n+\t\t\t\tcase EQ:\n+\t\t\t\t\treturn \"EQ\";\n+\t\t\t\tcase NE:\n+\t\t\t\t\treturn \"NE\";\n+\t\t\t\tcase LT:\n+\t\t\t\t\treturn \"LT\";\n+\t\t\t\tcase LE:\n+\t\t\t\t\treturn \"LE\";\n+\t\t\t\tcase GT:\n+\t\t\t\t\treturn \"GT\";\n+\t\t\t\tcase GE:\n+\t\t\t\t\treturn \"GE\";\n+\t\t\t\tcase LSH:\n+\t\t\t\t\treturn \"LSH\";\n+\t\t\t\tcase RSH:\n+\t\t\t\t\treturn \"RSH\";\n+\t\t\t\tcase URSH:\n+\t\t\t\t\treturn \"URSH\";\n+\t\t\t\tcase ADD:\n+\t\t\t\t\treturn \"ADD\";\n+\t\t\t\tcase SUB:\n+\t\t\t\t\treturn \"SUB\";\n+\t\t\t\tcase MUL:\n+\t\t\t\t\treturn \"MUL\";\n+\t\t\t\tcase DIV:\n+\t\t\t\t\treturn \"DIV\";\n+\t\t\t\tcase MOD:\n+\t\t\t\t\treturn \"MOD\";\n+\t\t\t\tcase NOT:\n+\t\t\t\t\treturn \"NOT\";\n+\t\t\t\tcase BITNOT:\n+\t\t\t\t\treturn \"BITNOT\";\n+\t\t\t\tcase POS:\n+\t\t\t\t\treturn \"POS\";\n+\t\t\t\tcase NEG:\n+\t\t\t\t\treturn \"NEG\";\n+\t\t\t\tcase NEW:\n+\t\t\t\t\treturn \"NEW\";\n+\t\t\t\tcase DELPROP:\n+\t\t\t\t\treturn \"DELPROP\";\n+\t\t\t\tcase TYPEOF:\n+\t\t\t\t\treturn \"TYPEOF\";\n+\t\t\t\tcase GETPROP:\n+\t\t\t\t\treturn \"GETPROP\";\n+\t\t\t\tcase GETELEM:\n+\t\t\t\t\treturn \"GETELEM\";\n+\t\t\t\tcase CALL:\n+\t\t\t\t\treturn \"CALL\";\n+\t\t\t\tcase NAME:\n+\t\t\t\t\treturn \"NAME\";\n+\t\t\t\tcase LABEL_NAME:\n+\t\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\t\tcase NUMBER:\n+\t\t\t\t\treturn \"NUMBER\";\n+\t\t\t\tcase STRING:\n+\t\t\t\t\treturn \"STRING\";\n+\t\t\t\tcase STRING_KEY:\n+\t\t\t\t\treturn \"STRING_KEY\";\n+\t\t\t\tcase NULL:\n+\t\t\t\t\treturn \"NULL\";\n+\t\t\t\tcase THIS:\n+\t\t\t\t\treturn \"THIS\";\n+\t\t\t\tcase FALSE:\n+\t\t\t\t\treturn \"FALSE\";\n+\t\t\t\tcase TRUE:\n+\t\t\t\t\treturn \"TRUE\";\n+\t\t\t\tcase SHEQ:\n+\t\t\t\t\treturn \"SHEQ\";\n+\t\t\t\tcase SHNE:\n+\t\t\t\t\treturn \"SHNE\";\n+\t\t\t\tcase REGEXP:\n+\t\t\t\t\treturn \"REGEXP\";\n+\t\t\t\tcase THROW:\n+\t\t\t\t\treturn \"THROW\";\n+\t\t\t\tcase IN:\n+\t\t\t\t\treturn \"IN\";\n+\t\t\t\tcase INSTANCEOF:\n+\t\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\t\tcase ARRAYLIT:\n+\t\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\t\tcase OBJECTLIT:\n+\t\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\t\tcase TRY:\n+\t\t\t\t\treturn \"TRY\";\n+\t\t\t\tcase PARAM_LIST:\n+\t\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\t\tcase COMMA:\n+\t\t\t\t\treturn \"COMMA\";\n+\t\t\t\tcase ASSIGN:\n+\t\t\t\t\treturn \"ASSIGN\";\n+\t\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\t\tcase ASSIGN_LSH:\n+\t\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\t\tcase ASSIGN_RSH:\n+\t\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\t\tcase ASSIGN_URSH:\n+\t\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\t\tcase ASSIGN_ADD:\n+\t\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\t\tcase ASSIGN_SUB:\n+\t\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\t\tcase ASSIGN_MUL:\n+\t\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\t\tcase ASSIGN_DIV:\n+\t\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\t\tcase ASSIGN_MOD:\n+\t\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\t\tcase HOOK:\n+\t\t\t\t\treturn \"HOOK\";\n+\t\t\t\tcase OR:\n+\t\t\t\t\treturn \"OR\";\n+\t\t\t\tcase AND:\n+\t\t\t\t\treturn \"AND\";\n+\t\t\t\tcase INC:\n+\t\t\t\t\treturn \"INC\";\n+\t\t\t\tcase DEC:\n+\t\t\t\t\treturn \"DEC\";\n+\t\t\t\tcase FUNCTION:\n+\t\t\t\t\treturn \"FUNCTION\";\n+\t\t\t\tcase IF:\n+\t\t\t\t\treturn \"IF\";\n+\t\t\t\tcase SWITCH:\n+\t\t\t\t\treturn \"SWITCH\";\n+\t\t\t\tcase CASE:\n+\t\t\t\t\treturn \"CASE\";\n+\t\t\t\tcase DEFAULT_CASE:\n+\t\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\t\tcase WHILE:\n+\t\t\t\t\treturn \"WHILE\";\n+\t\t\t\tcase DO:\n+\t\t\t\t\treturn \"DO\";\n+\t\t\t\tcase FOR:\n+\t\t\t\t\treturn \"FOR\";\n+\t\t\t\tcase BREAK:\n+\t\t\t\t\treturn \"BREAK\";\n+\t\t\t\tcase CONTINUE:\n+\t\t\t\t\treturn \"CONTINUE\";\n+\t\t\t\tcase VAR:\n+\t\t\t\t\treturn \"VAR\";\n+\t\t\t\tcase WITH:\n+\t\t\t\t\treturn \"WITH\";\n+\t\t\t\tcase CATCH:\n+\t\t\t\t\treturn \"CATCH\";\n+\t\t\t\tcase EMPTY:\n+\t\t\t\t\treturn \"EMPTY\";\n+\t\t\t\tcase BLOCK:\n+\t\t\t\t\treturn \"BLOCK\";\n+\t\t\t\tcase LABEL:\n+\t\t\t\t\treturn \"LABEL\";\n+\t\t\t\tcase EXPR_RESULT:\n+\t\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\t\tcase SCRIPT:\n+\t\t\t\t\treturn \"SCRIPT\";\n+\t\t\t\tcase GETTER_DEF:\n+\t\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\t\tcase SETTER_DEF:\n+\t\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\t\tcase CONST:\n+\t\t\t\t\treturn \"CONST\";\n+\t\t\t\tcase DEBUGGER:\n+\t\t\t\t\treturn \"DEBUGGER\";\n+\t\t\t\tcase CAST:\n+\t\t\t\t\treturn \"CAST\";\n+\t\t\t\tcase ANNOTATION:\n+\t\t\t\t\treturn \"ANNOTATION\";\n+\t\t\t\tcase PIPE:\n+\t\t\t\t\treturn \"PIPE\";\n+\t\t\t\tcase STAR:\n+\t\t\t\t\treturn \"STAR\";\n+\t\t\t\tcase EOC:\n+\t\t\t\t\treturn \"EOC\";\n+\t\t\t\tcase QMARK:\n+\t\t\t\t\treturn \"QMARK\";\n+\t\t\t\tcase ELLIPSIS:\n+\t\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\t\tcase BANG:\n+\t\t\t\t\treturn \"BANG\";\n+\t\t\t\tcase VOID:\n+\t\t\t\t\treturn \"VOID\";\n+\t\t\t\tcase EQUALS:\n+\t\t\t\t\treturn \"EQUALS\";\n+\t\t\t\tcase LB:\n+\t\t\t\t\treturn \"LB\";\n+\t\t\t\tcase LC:\n+\t\t\t\t\treturn \"LC\";\n+\t\t\t\tcase COLON:\n+\t\t\t\t\treturn \"COLON\";\n+\t\t\t\t}\n+\t\t\t\treturn \"RETURN\";\n+\t\t\t}\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1882/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:39.140223204 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_447/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:44.835623261 -0500\n@@ -989,7 +989,10 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            {\n+\t\t\t\tthis.type = Type.OTHER;\n+\t\t\t\tbreak;\n+\t\t\t}\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_447/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:44.835623261 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1433, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1451/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:40.214890491 -0500\n@@ -1430,7 +1430,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1451/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:40.214890491 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1505/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:07.131448708 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1505/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:07.131448708 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1505/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:07.131448708 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 226, 
          "faulty": "Node newNode=alias.node.cloneTree();", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1165/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:06.111595330 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1165/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:06.111595330 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1641/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:22.857182233 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1641/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:22.857182233 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_876/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:30.720311013 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_698/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:56.790405616 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_698/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:56.790405616 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1456/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:42.338934690 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1456/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:04:42.338934690 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1247/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:50.612567523 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1247/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:50.616567610 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_772/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:37.219231765 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_772/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:37.223231847 -0500\n@@ -987,7 +987,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_772/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:58:37.223231847 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_772/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:37.223231847 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_723/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:09.462665658 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_723/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:09.462665658 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1971/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:09:28.345279380 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1971/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:28.345279380 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1433, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1214/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:02:33.516196349 -0500\n@@ -1430,7 +1430,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1214/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:33.516196349 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1214/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:33.520196435 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Delete", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_800/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:52.047532374 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_800/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:52.047532374 -0500\n@@ -178,7 +178,6 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n             }\n           }\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1555/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:35.452070490 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1555/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:35.452070490 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_82/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:40.455482565 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_82/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:40.459482640 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1580/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:47.380353478 -0500\n@@ -178,7 +178,7 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              break;\n             }\n           }\n         }\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_866/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:25.624208825 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_866/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:25.628208905 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Replace", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1423/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:25.582585251 -0500\n@@ -1443,7 +1443,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1423/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:25.582585251 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1326/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:36.929560163 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1326/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:36.933560248 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_921/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:56.268821569 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_921/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:56.272821649 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "sourcePosition=-1;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1147/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:01:56.243376951 -0500\n@@ -1443,7 +1443,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1147/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:56.247377039 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1944/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:09:14.148976458 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1944/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:14.148976458 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1944/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:14.152976543 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"RETURN\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_366/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:55:01.674675372 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"RETURN\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_366/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:01.674675372 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_167/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:24.228437844 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_167/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:24.228437844 -0500\n@@ -219,15 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_378/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:06.730787605 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_378/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:06.734787694 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_32/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:10.722922680 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_32/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:10.726922755 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_141/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:11.376130443 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_141/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:11.380130539 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1417, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_363/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:00.238643436 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_363/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:55:00.238643436 -0500\n@@ -1414,7 +1414,9 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1235/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:43.480413014 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1235/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:43.480413014 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1930/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:09:07.004823484 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1930/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:09:07.004823484 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1162/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:04.711564413 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1162/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:04.711564413 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_979/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:29.309477861 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1704/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:58.690001702 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1179/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:13.051748277 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1179/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:13.051748277 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_289/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:25.761868118 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_289/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:25.765868208 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_289/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:25.765868208 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_963/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:19.285279195 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_963/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:19.285279195 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_963/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:19.285279195 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_847/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:16.988035371 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            ;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_847/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:16.988035371 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1060/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:10.594351725 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_746/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:22.290927870 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_746/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:22.294927950 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_576/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:51.981057828 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_576/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:51.985057912 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_741/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:19.414869170 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_741/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:58:19.418869252 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_741/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:19.418869252 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1497/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:03.515373949 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_859/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:22.784151822 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_118/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:59.395840886 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_433/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:37.015453159 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_433/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:37.015453159 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_286/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:24.249833719 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1933/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:08.388853147 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1768/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:32.750766354 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1768/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:32.754766444 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case ADD:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1205/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:02:27.844072582 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1205/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:27.848072668 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1205/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:27.848072668 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_192/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:36.420726512 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_192/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:36.420726512 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1448/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:38.814861340 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_542/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:34.016678244 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1131/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:47.063172809 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1131/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:01:47.067172897 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1131/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:47.067172897 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_284/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:23.549817781 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_284/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:23.553817872 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_64/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:30.343292271 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_64/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:30.347292346 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_64/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:30.347292346 -0500\n@@ -230,11 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 184, 
          "faulty": "return \"RETURN\";", 
          "type": "InsertBefore", 
          "seed": "switch (token) {\ncase ERROR:\n  return \"ERROR\";\ncase RETURN:\nreturn \"RETURN\";\ncase BITOR:\nreturn \"BITOR\";\ncase BITXOR:\nreturn \"BITXOR\";\ncase BITAND:\nreturn \"BITAND\";\ncase EQ:\nreturn \"EQ\";\ncase NE:\nreturn \"NE\";\ncase LT:\nreturn \"LT\";\ncase LE:\nreturn \"LE\";\ncase GT:\nreturn \"GT\";\ncase GE:\nreturn \"GE\";\ncase LSH:\nreturn \"LSH\";\ncase RSH:\nreturn \"RSH\";\ncase URSH:\nreturn \"URSH\";\ncase ADD:\nreturn \"ADD\";\ncase SUB:\nreturn \"SUB\";\ncase MUL:\nreturn \"MUL\";\ncase DIV:\nreturn \"DIV\";\ncase MOD:\nreturn \"MOD\";\ncase NOT:\nreturn \"NOT\";\ncase BITNOT:\nreturn \"BITNOT\";\ncase POS:\nreturn \"POS\";\ncase NEG:\nreturn \"NEG\";\ncase NEW:\nreturn \"NEW\";\ncase DELPROP:\nreturn \"DELPROP\";\ncase TYPEOF:\nreturn \"TYPEOF\";\ncase GETPROP:\nreturn \"GETPROP\";\ncase GETELEM:\nreturn \"GETELEM\";\ncase CALL:\nreturn \"CALL\";\ncase NAME:\nreturn \"NAME\";\ncase LABEL_NAME:\nreturn \"LABEL_NAME\";\ncase NUMBER:\nreturn \"NUMBER\";\ncase STRING:\nreturn \"STRING\";\ncase STRING_KEY:\nreturn \"STRING_KEY\";\ncase NULL:\nreturn \"NULL\";\ncase THIS:\nreturn \"THIS\";\ncase FALSE:\nreturn \"FALSE\";\ncase TRUE:\nreturn \"TRUE\";\ncase SHEQ:\nreturn \"SHEQ\";\ncase SHNE:\nreturn \"SHNE\";\ncase REGEXP:\nreturn \"REGEXP\";\ncase THROW:\nreturn \"THROW\";\ncase IN:\nreturn \"IN\";\ncase INSTANCEOF:\nreturn \"INSTANCEOF\";\ncase ARRAYLIT:\nreturn \"ARRAYLIT\";\ncase OBJECTLIT:\nreturn \"OBJECTLIT\";\ncase TRY:\nreturn \"TRY\";\ncase PARAM_LIST:\nreturn \"PARAM_LIST\";\ncase COMMA:\nreturn \"COMMA\";\ncase ASSIGN:\nreturn \"ASSIGN\";\ncase ASSIGN_BITOR:\nreturn \"ASSIGN_BITOR\";\ncase ASSIGN_BITXOR:\nreturn \"ASSIGN_BITXOR\";\ncase ASSIGN_BITAND:\nreturn \"ASSIGN_BITAND\";\ncase ASSIGN_LSH:\nreturn \"ASSIGN_LSH\";\ncase ASSIGN_RSH:\nreturn \"ASSIGN_RSH\";\ncase ASSIGN_URSH:\nreturn \"ASSIGN_URSH\";\ncase ASSIGN_ADD:\nreturn \"ASSIGN_ADD\";\ncase ASSIGN_SUB:\nreturn \"ASSIGN_SUB\";\ncase ASSIGN_MUL:\nreturn \"ASSIGN_MUL\";\ncase ASSIGN_DIV:\nreturn \"ASSIGN_DIV\";\ncase ASSIGN_MOD:\nreturn \"ASSIGN_MOD\";\ncase HOOK:\nreturn \"HOOK\";\ncase OR:\nreturn \"OR\";\ncase AND:\nreturn \"AND\";\ncase INC:\nreturn \"INC\";\ncase DEC:\nreturn \"DEC\";\ncase FUNCTION:\nreturn \"FUNCTION\";\ncase IF:\nreturn \"IF\";\ncase SWITCH:\nreturn \"SWITCH\";\ncase CASE:\nreturn \"CASE\";\ncase DEFAULT_CASE:\nreturn \"DEFAULT_CASE\";\ncase WHILE:\nreturn \"WHILE\";\ncase DO:\nreturn \"DO\";\ncase FOR:\nreturn \"FOR\";\ncase BREAK:\nreturn \"BREAK\";\ncase CONTINUE:\nreturn \"CONTINUE\";\ncase VAR:\nreturn \"VAR\";\ncase WITH:\nreturn \"WITH\";\ncase CATCH:\nreturn \"CATCH\";\ncase EMPTY:\nreturn \"EMPTY\";\ncase BLOCK:\nreturn \"BLOCK\";\ncase LABEL:\nreturn \"LABEL\";\ncase EXPR_RESULT:\nreturn \"EXPR_RESULT\";\ncase SCRIPT:\nreturn \"SCRIPT\";\ncase GETTER_DEF:\nreturn \"GETTER_DEF\";\ncase SETTER_DEF:\nreturn \"SETTER_DEF\";\ncase CONST:\nreturn \"CONST\";\ncase DEBUGGER:\nreturn \"DEBUGGER\";\ncase CAST:\nreturn \"CAST\";\ncase ANNOTATION:\nreturn \"ANNOTATION\";\ncase PIPE:\nreturn \"PIPE\";\ncase STAR:\nreturn \"STAR\";\ncase EOC:\nreturn \"EOC\";\ncase QMARK:\nreturn \"QMARK\";\ncase ELLIPSIS:\nreturn \"ELLIPSIS\";\ncase BANG:\nreturn \"BANG\";\ncase VOID:\nreturn \"VOID\";\ncase EQUALS:\nreturn \"EQUALS\";\ncase LB:\nreturn \"LB\";\ncase LC:\nreturn \"LC\";\ncase COLON:\nreturn \"COLON\";\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_312/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:54:36.478110924 -0500\n@@ -181,7 +181,213 @@\n   public static String name(int token) {\n         switch (token) {\n           case ERROR:           return \"ERROR\";\n-          case RETURN:          return \"RETURN\";\n+          case RETURN:          {\n+\t\t\t\tswitch (token) {\n+\t\t\t\tcase ERROR:\n+\t\t\t\t\treturn \"ERROR\";\n+\t\t\t\tcase RETURN:\n+\t\t\t\t\treturn \"RETURN\";\n+\t\t\t\tcase BITOR:\n+\t\t\t\t\treturn \"BITOR\";\n+\t\t\t\tcase BITXOR:\n+\t\t\t\t\treturn \"BITXOR\";\n+\t\t\t\tcase BITAND:\n+\t\t\t\t\treturn \"BITAND\";\n+\t\t\t\tcase EQ:\n+\t\t\t\t\treturn \"EQ\";\n+\t\t\t\tcase NE:\n+\t\t\t\t\treturn \"NE\";\n+\t\t\t\tcase LT:\n+\t\t\t\t\treturn \"LT\";\n+\t\t\t\tcase LE:\n+\t\t\t\t\treturn \"LE\";\n+\t\t\t\tcase GT:\n+\t\t\t\t\treturn \"GT\";\n+\t\t\t\tcase GE:\n+\t\t\t\t\treturn \"GE\";\n+\t\t\t\tcase LSH:\n+\t\t\t\t\treturn \"LSH\";\n+\t\t\t\tcase RSH:\n+\t\t\t\t\treturn \"RSH\";\n+\t\t\t\tcase URSH:\n+\t\t\t\t\treturn \"URSH\";\n+\t\t\t\tcase ADD:\n+\t\t\t\t\treturn \"ADD\";\n+\t\t\t\tcase SUB:\n+\t\t\t\t\treturn \"SUB\";\n+\t\t\t\tcase MUL:\n+\t\t\t\t\treturn \"MUL\";\n+\t\t\t\tcase DIV:\n+\t\t\t\t\treturn \"DIV\";\n+\t\t\t\tcase MOD:\n+\t\t\t\t\treturn \"MOD\";\n+\t\t\t\tcase NOT:\n+\t\t\t\t\treturn \"NOT\";\n+\t\t\t\tcase BITNOT:\n+\t\t\t\t\treturn \"BITNOT\";\n+\t\t\t\tcase POS:\n+\t\t\t\t\treturn \"POS\";\n+\t\t\t\tcase NEG:\n+\t\t\t\t\treturn \"NEG\";\n+\t\t\t\tcase NEW:\n+\t\t\t\t\treturn \"NEW\";\n+\t\t\t\tcase DELPROP:\n+\t\t\t\t\treturn \"DELPROP\";\n+\t\t\t\tcase TYPEOF:\n+\t\t\t\t\treturn \"TYPEOF\";\n+\t\t\t\tcase GETPROP:\n+\t\t\t\t\treturn \"GETPROP\";\n+\t\t\t\tcase GETELEM:\n+\t\t\t\t\treturn \"GETELEM\";\n+\t\t\t\tcase CALL:\n+\t\t\t\t\treturn \"CALL\";\n+\t\t\t\tcase NAME:\n+\t\t\t\t\treturn \"NAME\";\n+\t\t\t\tcase LABEL_NAME:\n+\t\t\t\t\treturn \"LABEL_NAME\";\n+\t\t\t\tcase NUMBER:\n+\t\t\t\t\treturn \"NUMBER\";\n+\t\t\t\tcase STRING:\n+\t\t\t\t\treturn \"STRING\";\n+\t\t\t\tcase STRING_KEY:\n+\t\t\t\t\treturn \"STRING_KEY\";\n+\t\t\t\tcase NULL:\n+\t\t\t\t\treturn \"NULL\";\n+\t\t\t\tcase THIS:\n+\t\t\t\t\treturn \"THIS\";\n+\t\t\t\tcase FALSE:\n+\t\t\t\t\treturn \"FALSE\";\n+\t\t\t\tcase TRUE:\n+\t\t\t\t\treturn \"TRUE\";\n+\t\t\t\tcase SHEQ:\n+\t\t\t\t\treturn \"SHEQ\";\n+\t\t\t\tcase SHNE:\n+\t\t\t\t\treturn \"SHNE\";\n+\t\t\t\tcase REGEXP:\n+\t\t\t\t\treturn \"REGEXP\";\n+\t\t\t\tcase THROW:\n+\t\t\t\t\treturn \"THROW\";\n+\t\t\t\tcase IN:\n+\t\t\t\t\treturn \"IN\";\n+\t\t\t\tcase INSTANCEOF:\n+\t\t\t\t\treturn \"INSTANCEOF\";\n+\t\t\t\tcase ARRAYLIT:\n+\t\t\t\t\treturn \"ARRAYLIT\";\n+\t\t\t\tcase OBJECTLIT:\n+\t\t\t\t\treturn \"OBJECTLIT\";\n+\t\t\t\tcase TRY:\n+\t\t\t\t\treturn \"TRY\";\n+\t\t\t\tcase PARAM_LIST:\n+\t\t\t\t\treturn \"PARAM_LIST\";\n+\t\t\t\tcase COMMA:\n+\t\t\t\t\treturn \"COMMA\";\n+\t\t\t\tcase ASSIGN:\n+\t\t\t\t\treturn \"ASSIGN\";\n+\t\t\t\tcase ASSIGN_BITOR:\n+\t\t\t\t\treturn \"ASSIGN_BITOR\";\n+\t\t\t\tcase ASSIGN_BITXOR:\n+\t\t\t\t\treturn \"ASSIGN_BITXOR\";\n+\t\t\t\tcase ASSIGN_BITAND:\n+\t\t\t\t\treturn \"ASSIGN_BITAND\";\n+\t\t\t\tcase ASSIGN_LSH:\n+\t\t\t\t\treturn \"ASSIGN_LSH\";\n+\t\t\t\tcase ASSIGN_RSH:\n+\t\t\t\t\treturn \"ASSIGN_RSH\";\n+\t\t\t\tcase ASSIGN_URSH:\n+\t\t\t\t\treturn \"ASSIGN_URSH\";\n+\t\t\t\tcase ASSIGN_ADD:\n+\t\t\t\t\treturn \"ASSIGN_ADD\";\n+\t\t\t\tcase ASSIGN_SUB:\n+\t\t\t\t\treturn \"ASSIGN_SUB\";\n+\t\t\t\tcase ASSIGN_MUL:\n+\t\t\t\t\treturn \"ASSIGN_MUL\";\n+\t\t\t\tcase ASSIGN_DIV:\n+\t\t\t\t\treturn \"ASSIGN_DIV\";\n+\t\t\t\tcase ASSIGN_MOD:\n+\t\t\t\t\treturn \"ASSIGN_MOD\";\n+\t\t\t\tcase HOOK:\n+\t\t\t\t\treturn \"HOOK\";\n+\t\t\t\tcase OR:\n+\t\t\t\t\treturn \"OR\";\n+\t\t\t\tcase AND:\n+\t\t\t\t\treturn \"AND\";\n+\t\t\t\tcase INC:\n+\t\t\t\t\treturn \"INC\";\n+\t\t\t\tcase DEC:\n+\t\t\t\t\treturn \"DEC\";\n+\t\t\t\tcase FUNCTION:\n+\t\t\t\t\treturn \"FUNCTION\";\n+\t\t\t\tcase IF:\n+\t\t\t\t\treturn \"IF\";\n+\t\t\t\tcase SWITCH:\n+\t\t\t\t\treturn \"SWITCH\";\n+\t\t\t\tcase CASE:\n+\t\t\t\t\treturn \"CASE\";\n+\t\t\t\tcase DEFAULT_CASE:\n+\t\t\t\t\treturn \"DEFAULT_CASE\";\n+\t\t\t\tcase WHILE:\n+\t\t\t\t\treturn \"WHILE\";\n+\t\t\t\tcase DO:\n+\t\t\t\t\treturn \"DO\";\n+\t\t\t\tcase FOR:\n+\t\t\t\t\treturn \"FOR\";\n+\t\t\t\tcase BREAK:\n+\t\t\t\t\treturn \"BREAK\";\n+\t\t\t\tcase CONTINUE:\n+\t\t\t\t\treturn \"CONTINUE\";\n+\t\t\t\tcase VAR:\n+\t\t\t\t\treturn \"VAR\";\n+\t\t\t\tcase WITH:\n+\t\t\t\t\treturn \"WITH\";\n+\t\t\t\tcase CATCH:\n+\t\t\t\t\treturn \"CATCH\";\n+\t\t\t\tcase EMPTY:\n+\t\t\t\t\treturn \"EMPTY\";\n+\t\t\t\tcase BLOCK:\n+\t\t\t\t\treturn \"BLOCK\";\n+\t\t\t\tcase LABEL:\n+\t\t\t\t\treturn \"LABEL\";\n+\t\t\t\tcase EXPR_RESULT:\n+\t\t\t\t\treturn \"EXPR_RESULT\";\n+\t\t\t\tcase SCRIPT:\n+\t\t\t\t\treturn \"SCRIPT\";\n+\t\t\t\tcase GETTER_DEF:\n+\t\t\t\t\treturn \"GETTER_DEF\";\n+\t\t\t\tcase SETTER_DEF:\n+\t\t\t\t\treturn \"SETTER_DEF\";\n+\t\t\t\tcase CONST:\n+\t\t\t\t\treturn \"CONST\";\n+\t\t\t\tcase DEBUGGER:\n+\t\t\t\t\treturn \"DEBUGGER\";\n+\t\t\t\tcase CAST:\n+\t\t\t\t\treturn \"CAST\";\n+\t\t\t\tcase ANNOTATION:\n+\t\t\t\t\treturn \"ANNOTATION\";\n+\t\t\t\tcase PIPE:\n+\t\t\t\t\treturn \"PIPE\";\n+\t\t\t\tcase STAR:\n+\t\t\t\t\treturn \"STAR\";\n+\t\t\t\tcase EOC:\n+\t\t\t\t\treturn \"EOC\";\n+\t\t\t\tcase QMARK:\n+\t\t\t\t\treturn \"QMARK\";\n+\t\t\t\tcase ELLIPSIS:\n+\t\t\t\t\treturn \"ELLIPSIS\";\n+\t\t\t\tcase BANG:\n+\t\t\t\t\treturn \"BANG\";\n+\t\t\t\tcase VOID:\n+\t\t\t\t\treturn \"VOID\";\n+\t\t\t\tcase EQUALS:\n+\t\t\t\t\treturn \"EQUALS\";\n+\t\t\t\tcase LB:\n+\t\t\t\t\treturn \"LB\";\n+\t\t\t\tcase LC:\n+\t\t\t\t\treturn \"LC\";\n+\t\t\t\tcase COLON:\n+\t\t\t\t\treturn \"COLON\";\n+\t\t\t\t}\n+\t\t\t\treturn \"RETURN\";\n+\t\t\t}\n           case BITOR:           return \"BITOR\";\n           case BITXOR:          return \"BITXOR\";\n           case BITAND:          return \"BITAND\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_312/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:36.482111013 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_329/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:45.798320741 -0500\n@@ -988,7 +988,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_329/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:45.798320741 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_881/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:33.576368232 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_881/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:33.580368313 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1593/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:55.140536367 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1593/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:55.144536460 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1415/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:22.002510366 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1415/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:22.002510366 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_470/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:55.383851626 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1409/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:18.338433638 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_472/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:56.183868899 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_472/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:56.183868899 -0500\n@@ -224,7 +224,6 @@\n               aliasRefs.references.get(i);\n \n           Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n           newNodes.add(newNode);\n         }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_997/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:38.521660111 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_997/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:38.521660111 -0500\n@@ -178,7 +178,9 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t}\n             }\n           }\n         }\n@@ -213,30 +215,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_407/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:23.047147569 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_407/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:23.051147657 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n@@ -988,7 +987,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_407/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:23.051147657 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_51/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:22.835150899 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_51/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:22.835150899 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_373/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:04.530738811 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_373/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:04.534738900 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1491/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:00.715316012 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1889/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:43.288312945 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1889/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:43.292313032 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_67/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:52:31.847320582 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_67/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:31.847320582 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_67/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:31.851320658 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n@@ -309,7 +310,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1168/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:07.479625518 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1168/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:07.479625518 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_805/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:54.815588359 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_320/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:40.022190856 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"ADD\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_520/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:56:22.804439843 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"ADD\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_520/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:22.804439843 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_314/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:37.226127809 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_314/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:37.226127809 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_314/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:37.230127900 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1800/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:07:50.331156169 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1800/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:50.331156169 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_351/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:54.434514073 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_351/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:54.434514073 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1048/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:04.974223653 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1048/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:04.974223653 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_678/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:46.274189011 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_678/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:46.278189093 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_516/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:20.692394803 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1084/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:22.574623318 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1417, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1536/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:05:25.527833253 -0500\n@@ -1414,7 +1414,9 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1536/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:25.527833253 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_504/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:14.328258821 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_504/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:14.328258821 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1549/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:32.576001909 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"RETURN\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_174/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:53:27.844523753 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"RETURN\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_174/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:27.848523848 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_174/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:27.848523848 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "for (n=first, n2=node2.first; res == null && n != null; n=n.next, n2=n2.next) {\n  if (node2 == null) {\n    throw new IllegalStateException();\n  }\n  res=n.checkTreeEqualsImpl(n2);\n  if (res != null) {\n    return res;\n  }\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_85/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:52:42.007511759 -0500\n@@ -1443,7 +1443,16 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        for (n = first, n2 = node2.first; res == null && n != null; n = n.next, n2 = n2.next) {\n+\t\t\tif (node2 == null) {\n+\t\t\t\tthrow new IllegalStateException();\n+\t\t\t}\n+\t\t\tres = n.checkTreeEqualsImpl(n2);\n+\t\t\tif (res != null) {\n+\t\t\t\treturn res;\n+\t\t\t}\n+\t\t}\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_85/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:42.011511834 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_85/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:42.011511834 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_238/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:59.489265319 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_238/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:59.489265319 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_238/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:59.493265412 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_532/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:29.128574456 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_532/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:29.128574456 -0500\n@@ -178,7 +178,9 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t}\n             }\n           }\n         }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_198/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:38.628778494 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_198/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:38.632778589 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_914/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:52.724750913 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_914/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:52.728750994 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1853/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:22.083852713 -0500\n@@ -178,7 +178,9 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t}\n             }\n           }\n         }\n@@ -213,30 +215,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1947/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:15.541006222 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_566/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:46.196935920 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1967/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:26.905248716 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1366/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:57.109987356 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_712/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:03.886551363 -0500\n@@ -988,7 +988,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_712/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:03.890551445 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_993/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:37.081631642 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_993/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:37.081631642 -0500\n@@ -224,7 +224,6 @@\n               aliasRefs.references.get(i);\n \n           Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n           newNodes.add(newNode);\n         }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Replace", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_305/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:33.670047463 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_307/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:34.366063203 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_886/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:36.388424533 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_886/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:36.388424533 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "return \"BITOR\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_941/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:00:06.209019465 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_941/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:06.209019465 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1322/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:34.841515788 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1399/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:13.446331061 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1399/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:04:13.450331145 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1399/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:13.450331145 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 226, 
          "faulty": "Node newNode=alias.node.cloneTree();", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_186/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:33.548658764 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_186/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:33.552658858 -0500\n@@ -219,15 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1557/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:36.156087256 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1557/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:36.156087256 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_160/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:21.364369623 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_160/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:21.364369623 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_160/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:21.364369623 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1659/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:33.361424179 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_353/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:55.242532109 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_353/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:55.246532199 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_353/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:55.246532199 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1176/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:11.635717111 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_151/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:17.688281825 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_151/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:17.692281922 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Replace", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1056/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:08.502304101 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "this.type=Type.OTHER;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_416/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:27.535246006 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_416/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:27.535246006 -0500\n@@ -989,7 +989,10 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            {\n+\t\t\t\tthis.type = Type.OTHER;\n+\t\t\t\tbreak;\n+\t\t\t}\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1841/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:15.075699766 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1841/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:15.079699852 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_460/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:50.519746470 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_460/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:50.519746470 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_984/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:31.525521731 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n@@ -309,7 +308,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_984/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:31.525521731 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1278/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:09.384972015 -0500\n@@ -988,7 +988,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1278/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:09.384972015 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1631/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:17.217051699 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"ADD\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_660/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:35.509966506 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"ADD\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_660/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:35.509966506 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1038/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:00:59.950108795 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1038/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:59.950108795 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_974/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:26.505422326 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_974/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:26.509422405 -0500\n@@ -178,7 +178,7 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              break;\n             }\n           }\n         }\n@@ -235,7 +235,7 @@\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n+        return false;\n       }\n     }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1093/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:26.842719625 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1093/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:26.842719625 -0500\n@@ -178,7 +178,7 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              break;\n             }\n           }\n         }\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_686/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:50.430274704 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1687/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:50.877824431 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1079/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:19.766559830 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1079/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:19.766559830 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_753/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:25.839000216 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_753/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:25.843000297 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_894/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:40.592508636 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_927/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:59.092877833 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_927/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:59.096877914 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_48/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:21.375123399 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_48/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:21.379123475 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case BLOCK:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1137/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:01:50.571250933 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1137/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:50.575251021 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1137/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:50.575251021 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_628/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:19.781639877 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1232/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:42.092382891 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_841/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:14.187979056 -0500\n@@ -178,7 +178,9 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t}\n             }\n           }\n         }\n@@ -213,30 +215,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_349/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:53.718498083 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_349/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:53.722498171 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1762/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:29.962704244 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_431/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:36.307437723 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1610/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:04.496755645 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1610/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:04.496755645 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_403/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:20.931101072 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1193/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:21.431932278 -0500\n@@ -177,9 +177,9 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1193/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:21.435932366 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1417, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "InsertBefore", 
          "seed": "if (diff != null) {\n  return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1764/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:07:30.666719934 -0500\n@@ -1414,7 +1414,13 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n+        if (diff != null) {\n+\t\t\treturn \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree()\n+\t\t\t\t\t+ \"\\n\\nTree2:\\n\" + node2.toStringTree() + \"\\n\\nSubtree1: \"\n+\t\t\t\t\t+ diff.nodeA.toStringTree() + \"\\n\\nSubtree2: \"\n+\t\t\t\t\t+ diff.nodeB.toStringTree();\n+\t\t}\n+\t\treturn \"Node tree inequality:\" +\n             \"\\nTree1:\\n\" + toStringTree() +\n             \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n             \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1764/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:30.670720022 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "sourcePosition=-1;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_899/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:43.412565009 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_899/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:43.416565089 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_899/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:43.416565089 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_827/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:06.903832374 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1716/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:04.582134919 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_128/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:04.567966260 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_128/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:04.571966356 -0500\n@@ -987,7 +987,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1779/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:39.022905790 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1779/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:07:39.022905790 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_583/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:54.821117580 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_583/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:54.821117580 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_702/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:57:58.218434973 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_702/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:58.218434973 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1404/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:16.262390128 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_225/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:53.121117508 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_225/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:53.125117601 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_225/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:53.125117601 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_133/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:06.784019807 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_133/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:06.784019807 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1465/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:04:46.631023928 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"SUB\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1465/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:46.631023928 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1076/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:18.298526597 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1076/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:18.302526688 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_636/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:22.725701157 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_636/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:22.725701157 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "InsertBefore", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1865/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:08:29.100005410 -0500\n@@ -989,7 +989,10 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            {\n+\t\t\t\tthis.type = Type.OTHER;\n+\t\t\t\tbreak;\n+\t\t\t}\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1865/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:29.100005410 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1469/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:48.815069296 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1469/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:48.815069296 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1469/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:48.815069296 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_458/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:49.815731229 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_458/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:49.815731229 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1041/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:01:01.418142391 -0500\n@@ -987,7 +987,7 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            ;\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1041/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:01.418142391 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1472/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:50.207098196 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1472/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:50.207098196 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_89/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:44.203553064 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_89/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:44.203553064 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n@@ -208,7 +204,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1433, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Delete", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_844/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:15.592007297 -0500\n@@ -1430,7 +1430,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_844/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:15.592007297 -0500\n@@ -178,7 +178,6 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n             }\n           }\n         }\n@@ -213,30 +212,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_345/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:52.286466081 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_345/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:52.290466171 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1044/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:02.802174039 -0500\n@@ -178,7 +178,10 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\tname.removeRef(ref);\n             }\n           }\n         }\n@@ -213,30 +216,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1935/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:09:09.080867975 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1893/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:45.720365499 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1893/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:45.720365499 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_873/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:29.348283514 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_873/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:29.348283514 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Replace", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1195/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:22.151948054 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1195/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:22.151948054 -0500\n@@ -179,7 +179,7 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n   }\n \n   /**\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_357/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:57.422580728 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1228/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:40.028338061 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1228/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:40.032338147 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_493/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:07.904121153 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_590/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:58.449193812 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_590/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:58.453193896 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1051/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:06.426256783 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1343/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:03:44.877728771 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1343/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:44.881728856 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1702/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:57.981985668 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1090/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:25.346685896 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1090/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:25.346685896 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_230/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:55.257167164 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_230/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:53:55.257167164 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1065/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:12.682399198 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_795/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:49.251475783 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_795/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:49.251475783 -0500\n@@ -987,7 +987,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1926/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:04.916778705 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1129/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:46.347156845 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1129/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:01:46.351156933 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_454/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:47.659684520 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_454/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:47.659684520 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_412/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:26.027212959 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_412/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:26.027212959 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1855/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:08:22.795868228 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1855/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:22.799868314 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1364/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:56.401972416 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_930/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:00.516906192 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_930/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:00.516906192 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_957/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:15.597206007 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n@@ -988,7 +987,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            this.type = Type.OTHER;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_957/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:15.601206086 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_545/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:35.480709286 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_545/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:35.484709371 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_585/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:55.537132633 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_585/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:55.541132717 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n@@ -989,7 +990,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            ;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_946/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:09.029075537 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_816/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:00.651706262 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_343/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:51.578450249 -0500\n@@ -178,7 +178,9 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t}\n             }\n           }\n         }\n@@ -213,30 +215,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1218/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:35.688243660 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1218/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:35.692243748 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_369/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:03.098707017 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_369/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:03.102707107 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_369/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:03.102707107 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1419/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:24.182555976 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1419/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:24.182555976 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_491/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:07.208106213 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1036/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:59.250092761 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1036/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:00:59.254092854 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1036/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:59.254092854 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Replace", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1223/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:37.900291796 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1223/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:37.900291796 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"RETURN\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1069/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:14.782446885 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1069/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:01:14.786446977 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"RETURN\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1069/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:14.786446977 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_903/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:45.544607605 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_903/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:45.544607605 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1697/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:55.817936616 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1697/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:06:55.817936616 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1697/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:55.821936706 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_581/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:54.113102690 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_581/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:54.117102775 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_864/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:24.920194699 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_526/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:26.276513795 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_526/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:26.276513795 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_526/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:26.280513879 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1675/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:43.937666314 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1675/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:43.941666406 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_553/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:56:39.736799419 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"SUB\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_553/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:39.736799419 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_553/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:39.740799504 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_208/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:43.716897944 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_208/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:43.716897944 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_208/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:43.720898038 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_857/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:22.092137928 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_857/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:22.092137928 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_857/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:22.096138008 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "case PARAM_LIST:"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_94/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:52:46.423594814 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_94/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:46.423594814 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_94/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:46.427594889 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1694/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:54.409904671 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1694/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:54.413904762 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1606/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:06:02.220702424 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1606/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:02.220702424 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_948/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:09.857091993 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_948/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:09.857091993 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_421/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:30.335307300 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_421/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:30.335307300 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1796/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:48.227109678 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1575/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:45.252303159 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1575/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:45.256303255 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1118/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:41.327044752 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1118/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:01:41.331044842 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1118/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:41.331044842 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_24/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:05.378821924 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_696/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:56.082391057 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_220/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:50.977067587 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_220/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:50.977067587 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_164/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:22.796403754 -0500\n@@ -179,7 +179,6 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_164/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:22.796403754 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_774/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:37.931246228 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_774/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:37.935246309 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1221/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:02:37.120274829 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        sourcePosition = -1;\n+\t\treturn res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1221/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:37.124274915 -0500\n@@ -988,7 +988,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1221/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:37.124274915 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1006/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:00:42.793744524 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1006/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:42.793744524 -0500\n@@ -219,17 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1816/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:00.051370389 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1373/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:00.718063423 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1531/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:23.319782538 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1531/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:23.319782538 -0500\n@@ -228,8 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_114/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:57.247798295 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_114/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:52:57.247798295 -0500\n@@ -228,13 +228,8 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1333/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:40.561637271 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1333/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:40.561637271 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"ADD\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_244/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:02.389332406 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"ADD\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_244/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:02.389332406 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_675/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:44.858159788 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_675/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:44.858159788 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"ADD\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_789/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:58:45.791405694 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"ADD\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_789/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:45.795405775 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_789/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:45.795405775 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_476/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:58.375916187 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_476/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:55:58.379916272 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_476/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:58.379916272 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"BITOR\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1952/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:09:17.649051271 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"BITOR\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1952/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:09:17.649051271 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1952/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:17.653051357 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1743/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:18.558449315 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1567/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:41.092204585 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n@@ -309,7 +305,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1567/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:41.092204585 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1063/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:01:11.986383381 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1063/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:11.990383473 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "this.type=Type.OTHER;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_155/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:19.212318258 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_155/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:19.216318353 -0500\n@@ -987,8 +987,11 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n-            totalGets--;\n+            {\n+\t\t\t\tthis.type = Type.OTHER;\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_155/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:19.216318353 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1699/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:06:56.569953668 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1699/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:06:56.573953758 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1699/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:06:56.573953758 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_451/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:46.227653468 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"BITOR\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Delete", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1741/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:07:17.870433890 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"BITOR\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1741/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:17.874433978 -0500\n@@ -178,7 +178,6 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n             }\n           }\n         }\n@@ -210,33 +209,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_266/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:13.269582867 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_266/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:13.273582958 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 991, 
          "faulty": "totalGets--;", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1726/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:09.518246210 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1726/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:07:09.522246302 -0500\n@@ -988,7 +988,7 @@\n             break;\n           case ALIASING_GET:\n             aliasingGets--;\n-            totalGets--;\n+            ;\n             break;\n           case CALL_GET:\n             callGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1726/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:09.522246302 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1454/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:41.630919961 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1454/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:41.630919961 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_262/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:10.957529805 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_262/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:10.957529805 -0500\n@@ -224,14 +224,11 @@\n               aliasRefs.references.get(i);\n \n           Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n           newNodes.add(newNode);\n         }\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_69/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:52:32.571334210 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_69/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:52:32.571334210 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_601/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:57:04.257315622 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"SUB\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_601/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:04.257315622 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"SCRIPT\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_925/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:58.380863651 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_925/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:58.380863651 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"SCRIPT\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_925/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:58.384863731 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1904/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:52.000500988 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1904/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:52.000500988 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_507/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:15.732288856 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_507/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:15.732288856 -0500\n@@ -230,8 +230,6 @@\n \n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_387/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:12.510915504 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1433, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1459/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:43.778964643 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1459/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:04:43.782964725 -0500\n@@ -1430,7 +1430,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1459/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:04:43.782964725 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1459/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:43.786964810 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_555/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:40.476815074 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_555/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:40.476815074 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1589/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:53.068487625 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1589/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:53.068487625 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1964/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:09:25.429217269 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"SUB\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1964/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:09:25.433217354 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1098/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:29.698783942 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1417, 
          "faulty": "return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();", 
          "type": "Replace", 
          "seed": "if (diff != null) {\n  return \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree() + \"\\n\\nTree2:\\n\"+ node2.toStringTree()+ \"\\n\\nSubtree1: \"+ diff.nodeA.toStringTree()+ \"\\n\\nSubtree2: \"+ diff.nodeB.toStringTree();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_462/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:55:51.255762399 -0500\n@@ -1414,11 +1414,12 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        if (diff != null) {\n+\t\t\treturn \"Node tree inequality:\" + \"\\nTree1:\\n\" + toStringTree()\n+\t\t\t\t\t+ \"\\n\\nTree2:\\n\" + node2.toStringTree() + \"\\n\\nSubtree1: \"\n+\t\t\t\t\t+ diff.nodeA.toStringTree() + \"\\n\\nSubtree2: \"\n+\t\t\t\t\t+ diff.nodeB.toStringTree();\n+\t\t}\n       }\n       return null;\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_462/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:51.259762486 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_282/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:22.765799923 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_282/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:22.765799923 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_334/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:47.986369822 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_334/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:47.986369822 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_251/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:05.281399168 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 199, 
          "faulty": "return false;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_732/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:15.106781150 -0500\n@@ -196,7 +196,6 @@\n     @Override\n     public boolean apply(Node n) {\n       if (!n.isQualifiedName()) {\n-        return false;\n       }\n \n       Node current;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_732/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:15.106781150 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1759/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:28.590673646 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1597/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:57.284586733 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1597/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:57.284586733 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1560/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:37.544120288 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1560/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:37.544120288 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_269/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:14.813618256 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_269/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:14.813618256 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1113/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:39.138995803 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_563/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:56:44.740905186 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_563/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:44.744905271 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_162/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:22.080386694 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_162/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:22.080386694 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_389/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:13.214931054 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_389/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:13.218931143 -0500\n@@ -219,15 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1433, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "sourcePosition=-1;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1922/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:09:02.816733636 -0500\n@@ -1430,7 +1430,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      sourcePosition = -1;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1922/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:09:02.820733721 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1426/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:26.962614097 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1551/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:33.260018232 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1086/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:23.266638949 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_136/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:08.344057441 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_136/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:08.344057441 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_665/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:38.422026781 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_203/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:40.760828604 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_203/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:40.760828604 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1150/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:57.727409861 -0500\n@@ -210,33 +210,8 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1315/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:30.681427278 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1315/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:30.685427365 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1431/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:29.718671666 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1242/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:47.716504841 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1242/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:02:47.720504928 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1242/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:47.720504928 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1297/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:03:20.789216267 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1297/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:20.789216267 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1878/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:08:37.068178325 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1878/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:37.072178411 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 238, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1295/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:20.077201050 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_130/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:05.375985796 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_130/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:05.375985796 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1501/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:05:05.695419027 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1122/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:42.723075954 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1122/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:42.723075954 -0500\n@@ -228,10 +228,6 @@\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n         namespace.scanNewNodes(alias.scope, newNodes);\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1253/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:54.164644301 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Replace", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1200/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:25.068011890 -0500\n@@ -178,7 +178,9 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t}\n             }\n           }\n         }\n@@ -213,30 +215,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1225/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:02:38.596306932 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1354/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:03:51.297864625 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1354/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:51.297864625 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1256/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:55.740678330 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1256/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:55.740678330 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_240/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:00.205281896 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_240/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:00.209281989 -0500\n@@ -178,7 +178,10 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\tname.removeRef(ref);\n             }\n           }\n         }\n@@ -213,30 +216,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Replace", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_190/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:53:35.696709448 -0500\n@@ -1443,7 +1443,8 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        Preconditions.checkState(this.propListHead == null,\n+\t\t\t\t\"Node has existing properties.\");\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_190/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:35.700709542 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_739/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:18.674854059 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_739/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:18.674854059 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_862/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:59:24.224180730 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n@@ -195,10 +196,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_862/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:24.224180730 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_222/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:51.709084638 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_222/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:51.709084638 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n@@ -987,7 +986,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_222/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:51.713084732 -0500\n@@ -232,9 +232,6 @@\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n         return true;\n       }\n     }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"ADD\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_299/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:30.885984432 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_299/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:54:30.889984522 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"ADD\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Delete", 
          "seed": "this.parent=parent;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_734/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:15.886797095 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_734/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:58:15.890797176 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            ;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 233, 
          "faulty": "compiler.reportCodeChange();", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_196/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:37.840759953 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_196/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:37.844760048 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1708/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:00.814049773 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1708/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:00.818049864 -0500\n@@ -219,15 +219,6 @@\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n         Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n         // just set the original alias to null.\n         aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_235/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:58.073232513 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_122/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:01.651895643 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_122/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:01.655895740 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_833/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:09.823891207 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_833/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:09.827891287 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_820/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:02.727748160 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_820/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:02.727748160 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "sourcePosition=-1;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1433, 
          "faulty": "return new NodeMismatch(this,node2);", 
          "type": "InsertBefore", 
          "seed": "this.sourcePosition=sourcePosition;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1350/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:03:49.173819711 -0500\n@@ -1430,7 +1430,8 @@\n    */\n   NodeMismatch checkTreeEqualsImpl(Node node2) {\n     if (!isEquivalentTo(node2, false, false)) {\n-      return new NodeMismatch(this, node2);\n+      this.sourcePosition = sourcePosition;\n+\treturn new NodeMismatch(this, node2);\n     }\n \n     NodeMismatch res = null;\n@@ -1443,7 +1444,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1350/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:03:49.177819796 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_177/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:29.260557327 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_177/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:29.260557327 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n@@ -309,7 +310,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_871/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:28.576268036 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_871/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:59:28.576268036 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_871/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:59:28.576268036 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_853/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:59:20.604108041 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1107/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:01:35.558915587 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1107/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:35.562915676 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 213, 
          "faulty": "(new NodeTraversal(compiler,collector)).traverseAtScope(scope);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1718/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:05.270150449 -0500\n@@ -210,33 +210,7 @@\n           new ReferenceCollectingCallback(compiler,\n               ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,\n               Predicates.<Var>equalTo(aliasVar));\n-      (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n-\n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "Delete", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_620/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:15.533551336 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_620/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:15.533551336 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_620/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:15.537551418 -0500\n@@ -224,12 +224,9 @@\n               aliasRefs.references.get(i);\n \n           Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n           newNodes.add(newNode);\n         }\n \n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n         compiler.reportCodeChange();\n \n         // Inlining the variable may have introduced new references\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_932/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:01.240920608 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_932/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:01.240920608 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 198, 
          "faulty": "if (!n.isQualifiedName()) {\n  return false;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_623/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:16.953580949 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_623/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:16.953580949 -0500\n@@ -195,10 +195,6 @@\n \n     @Override\n     public boolean apply(Node n) {\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n       Node current;\n       for (current = n;\n            current.isGetProp();\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_623/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:16.957581031 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_618/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:57:14.793535897 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_618/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:57:14.793535897 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_258/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:54:09.461495424 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 182, 
          "faulty": "t.traverseAtScope(scope);", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_194/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:37.140743474 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_194/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:53:37.144743568 -0500\n@@ -179,7 +179,8 @@\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n     NodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n+    this.inExterns = inExterns;\n+\tt.traverseAtScope(scope);\n   }\n \n   /**\n@@ -309,7 +310,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 211, 
          "faulty": "return current.isName() && newNodes.contains(current);", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1183/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:02:15.155794544 -0500\n@@ -208,7 +208,7 @@\n         }\n       }\n \n-      return current.isName() && newNodes.contains(current);\n+      return false;\n     }\n   }\n \n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1183/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:02:15.155794544 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1371/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:00.034049010 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_783/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:42.823345518 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Delete", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 992, 
          "faulty": "break;", 
          "type": "Replace", 
          "seed": "this.type=Type.OTHER;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1477/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:04:52.307141776 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            ;\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1477/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:04:52.311141859 -0500\n@@ -989,7 +989,7 @@\n           case ALIASING_GET:\n             aliasingGets--;\n             totalGets--;\n-            break;\n+            this.type = Type.OTHER;\n           case CALL_GET:\n             callGets--;\n             totalGets--;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1477/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:04:52.311141859 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "Delete", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1781/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:07:39.722921325 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1781/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:39.726921414 -0500\n@@ -178,7 +178,6 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n             }\n           }\n         }\n@@ -213,30 +212,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1912/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:57.008608818 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1912/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:57.008608818 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 990, 
          "faulty": "aliasingGets--;", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_347/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:54:53.002482087 -0500\n@@ -987,7 +987,12 @@\n             totalGets--;\n             break;\n           case ALIASING_GET:\n-            aliasingGets--;\n+            {\n+\t\t\t\tif (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\t\taliasingGets--;\n+\t\t\t}\n             totalGets--;\n             break;\n           case CALL_GET:\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_347/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:54:53.006482177 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1578/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:05:46.684337029 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1578/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:46.688337123 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1503/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:05:06.415433910 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1869/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:31.220051467 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1869/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:08:31.224051554 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 237, 
          "faulty": "namespace.scanNewNodes(alias.scope,newNodes);", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1819/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:01.427400641 -0500\n@@ -213,30 +213,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_651/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:57:31.229877803 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "return new NodeMismatch(this,node2);"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_484/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:56:03.696030747 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_484/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:56:03.700030832 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_484/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:56:03.700030832 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Token.java", 
          "line": 217, 
          "faulty": "return \"NULL\";", 
          "type": "Replace", 
          "seed": "return \"SUB\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 180, 
          "faulty": "NodeTraversal t=new NodeTraversal(compiler,new BuildGlobalNamespace(new NodeFilter(newNodes)));", 
          "type": "InsertBefore", 
          "seed": "this.inExterns=inExterns;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1902/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Token.java\t2018-12-01 09:08:51.236484521 -0500\n@@ -214,7 +214,7 @@\n           case NUMBER:          return \"NUMBER\";\n           case STRING:          return \"STRING\";\n           case STRING_KEY:      return \"STRING_KEY\";\n-          case NULL:            return \"NULL\";\n+          case NULL:            return \"SUB\";\n           case THIS:            return \"THIS\";\n           case FALSE:           return \"FALSE\";\n           case TRUE:            return \"TRUE\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1902/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:08:51.236484521 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1902/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:08:51.236484521 -0500\n@@ -177,7 +177,8 @@\n    * @param newNodes New nodes to check.\n    */\n   void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n+    this.inExterns = inExterns;\n+\tNodeTraversal t = new NodeTraversal(compiler,\n         new BuildGlobalNamespace(new NodeFilter(newNodes)));\n     t.traverseAtScope(scope);\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1902/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:08:51.240484608 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 1446, 
          "faulty": "return res;", 
          "type": "Delete", 
          "seed": "Preconditions.checkState(this.propListHead == null,\"Node has existing properties.\");"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_981/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 09:00:30.037492276 -0500\n@@ -1443,7 +1443,6 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n       }\n     }\n     return res;\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_981/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:00:30.041492355 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Replace", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_180/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:53:30.740592376 -0500\n@@ -474,7 +474,7 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n+        return false;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_180/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:53:30.744592471 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1950/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:09:16.937036059 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 232, 
          "faulty": "aliasParent.replaceChild(alias.node,IR.nullNode());", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 227, 
          "faulty": "aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1713/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:07:02.994099058 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 476, 
          "faulty": "if (size > 0 && references.get(0).isInitializingDeclaration()) {\n  return true;\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 228, 
          "faulty": "newNodes.add(newNode);", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_767/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:58:34.355173562 -0500\n@@ -473,9 +473,6 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n-      }\n       return false;\n     }\n   }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_767/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:34.359173642 -0500\n@@ -225,7 +225,6 @@\n \n           Node newNode = alias.node.cloneTree();\n           aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n         }\n \n         // just set the original alias to null.\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Replace", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 181, 
          "faulty": "name.removeRef(ref);", 
          "type": "InsertBefore", 
          "seed": "if (refs == null) {\n  refs=Lists.newArrayList();\n}"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_750/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:58:24.358970046 -0500\n@@ -178,7 +178,10 @@\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n             if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+              if (refs == null) {\n+\t\t\t\t\trefs = Lists.newArrayList();\n+\t\t\t\t}\n+\t\t\tname.removeRef(ref);\n             }\n           }\n         }\n@@ -213,30 +216,7 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n+      return false;\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/GlobalNamespace.java", 
          "line": 312, 
          "faulty": "return;", 
          "type": "Delete", 
          "seed": "NULL"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1397/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 09:04:12.558312424 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 08:45:43.173585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1397/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/GlobalNamespace.java\t2018-12-01 09:04:12.558312424 -0500\n@@ -309,7 +309,6 @@\n \n     public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n       }\n \n       // If we are traversing the externs, then we save a pointer to the scope\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 222, 
          "faulty": "for (int i=1; i < size; i++) {\n  ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n  Node newNode=alias.node.cloneTree();\n  aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n  newNodes.add(newNode);\n}", 
          "type": "Delete", 
          "seed": "NULL"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_1053/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 09:01:07.122272654 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }, 
    {
      "edits": [
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 216, 
          "faulty": "if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration() && aliasRefs.isAssignedOnceInLifetime()) {\n  int size=aliasRefs.references.size();\n  Set<Node> newNodes=Sets.newHashSetWithExpectedSize(size - 1);\n  for (int i=1; i < size; i++) {\n    ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);\n    Node newNode=alias.node.cloneTree();\n    aliasRef.getParent().replaceChild(aliasRef.getNode(),newNode);\n    newNodes.add(newNode);\n  }\n  aliasParent.replaceChild(alias.node,IR.nullNode());\n  compiler.reportCodeChange();\n  namespace.scanNewNodes(alias.scope,newNodes);\n  return true;\n}", 
          "type": "Delete", 
          "seed": "return false;"
        }, 
        {
          "path": "src/com/google/javascript/rhino/Node.java", 
          "line": 131, 
          "faulty": "return \"free_call\";", 
          "type": "Replace", 
          "seed": "return \"ADD\";"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/CollapseProperties.java", 
          "line": 223, 
          "faulty": "ReferenceCollectingCallback.Reference aliasRef=aliasRefs.references.get(i);", 
          "type": "InsertBefore", 
          "seed": "break;"
        }, 
        {
          "path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", 
          "line": 477, 
          "faulty": "return true;", 
          "type": "Delete", 
          "seed": "return false;"
        }
      ], 
      "patch": "--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:45:43.181585574 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_423/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\t2018-12-01 08:55:31.203326283 -0500\n@@ -474,7 +474,6 @@\n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n       if (size > 0 && references.get(0).isInitializingDeclaration()) {\n-        return true;\n       }\n       return false;\n     }\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:45:43.193585573 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_423/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/rhino/Node.java\t2018-12-01 08:55:31.207326370 -0500\n@@ -128,7 +128,7 @@\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n-        case FREE_CALL:          return \"free_call\";\n+        case FREE_CALL:          return \"ADD\";\n         case STATIC_SOURCE_FILE:    return \"source_file\";\n         case INPUT_ID:  return \"input_id\";\n         case LENGTH:    return \"length\";\n\n\n--- /tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:45:45.845585512 -0500\n+++ /tmp/Arja_Defects4J_Closure_130/patches_yo25/Patch_423/patched/tmp/Arja_Defects4J_Closure_130/src/com/google/javascript/jscomp/CollapseProperties.java\t2018-12-01 08:55:31.207326370 -0500\n@@ -213,30 +213,6 @@\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n-      if (aliasRefs.isWellDefined()\n-          && aliasRefs.firstReferenceIsAssigningDeclaration()\n-          && aliasRefs.isAssignedOnceInLifetime()) {\n-        // The alias is well-formed, so do the inlining now.\n-        int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n-        for (int i = 1; i < size; i++) {\n-          ReferenceCollectingCallback.Reference aliasRef =\n-              aliasRefs.references.get(i);\n-\n-          Node newNode = alias.node.cloneTree();\n-          aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n-        }\n-\n-        // just set the original alias to null.\n-        aliasParent.replaceChild(alias.node, IR.nullNode());\n-        compiler.reportCodeChange();\n-\n-        // Inlining the variable may have introduced new references\n-        // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n-        return true;\n-      }\n     }\n \n     return false;\n\n\n"
    }
  ]
}